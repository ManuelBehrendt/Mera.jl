<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Mera.jl</title><meta name="title" content="Tutorial · Mera.jl"/><meta property="og:title" content="Tutorial · Mera.jl"/><meta property="twitter:title" content="Tutorial · Mera.jl"/><meta name="description" content="Documentation for Mera.jl."/><meta property="og:description" content="Documentation for Mera.jl."/><meta property="twitter:description" content="Documentation for Mera.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Mera.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../00_multi_FirstSteps/">First Steps</a></li><li><span class="tocitem">1 Data Inspection</span><ul><li><a class="tocitem" href="../01_hydro_First_Inspection/">Hydro</a></li><li><a class="tocitem" href="../01_particles_First_Inspection/">Particles</a></li><li><a class="tocitem" href="../01_clumps_First_Inspection/">Clumps</a></li><li><a class="tocitem" href="../api/data_inspection/">API Reference</a></li></ul></li><li><span class="tocitem">2 Load by Selection</span><ul><li><a class="tocitem" href="../02_hydro_Load_Selections/">Hydro</a></li><li><a class="tocitem" href="../02_particles_Load_Selections/">Particles</a></li><li><a class="tocitem" href="../02_clumps_Load_Selections/">Clumps</a></li><li><a class="tocitem" href="../api/data_loading/">API Reference</a></li></ul></li><li><span class="tocitem">3 Get Subregions</span><ul><li><a class="tocitem" href="../03_hydro_Get_Subregions/">Hydro</a></li><li><a class="tocitem" href="../03_particles_Get_Subregions/">Particles</a></li><li><a class="tocitem" href="../03_clumps_Get_Subregions/">Clumps</a></li><li><a class="tocitem" href="../api/subregions/">API Reference</a></li></ul></li><li><span class="tocitem">4 Basic Calculations</span><ul><li><a class="tocitem" href="../04_multi_Basic_Calculations/">Tutorial</a></li><li><a class="tocitem" href="../api/calculations/">API Reference</a></li></ul></li><li><span class="tocitem">5 Mask/Filter/Meta</span><ul><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Advanced-Data-Manipulation-and-Selection-Techniques"><span>Advanced Data Manipulation and Selection Techniques</span></a></li><li><a class="tocitem" href="#Data-Loading-and-Environment-Setup"><span>Data Loading and Environment Setup</span></a></li><li><a class="tocitem" href="#Data-Selection-from-Tables"><span>Data Selection from Tables</span></a></li><li><a class="tocitem" href="#Filter-by-Condition"><span>Filter by Condition</span></a></li><li><a class="tocitem" href="#Conditional-Data-Filtering"><span>Conditional Data Filtering</span></a></li><li><a class="tocitem" href="#Create-a-New-DataSetType-from-a-Filtered-Data-Table"><span>Create a New DataSetType from a Filtered Data Table</span></a></li><li><a class="tocitem" href="#Multi-Criteria-Filtering"><span>Multi-Criteria Filtering</span></a></li><li><a class="tocitem" href="#Extend-the-Data-Table"><span>Extend the Data Table</span></a></li><li><a class="tocitem" href="#Data-Table-Extension-and-Modification"><span>Data Table Extension and Modification</span></a></li><li><a class="tocitem" href="#Data-Masking-Operations"><span>Data Masking Operations</span></a></li><li><a class="tocitem" href="#Tutorial-Summary"><span>Tutorial Summary</span></a></li></ul></li><li><a class="tocitem" href="../api/masking_filtering/">API Reference</a></li></ul></li><li><span class="tocitem">6 Projection</span><ul><li><a class="tocitem" href="../06_hydro_Projection/">Hydro</a></li><li><a class="tocitem" href="../06_particles_Projection/">Particles</a></li><li><a class="tocitem" href="../api/projections/">API Reference</a></li></ul></li><li><span class="tocitem">7 MERA-Files</span><ul><li><a class="tocitem" href="../07_multi_Mera_Files/">Mera-Files</a></li><li><a class="tocitem" href="../07_1_multi_Mera_Files_Converter/">Converter</a></li><li><a class="tocitem" href="../api/mera_files/">API Reference</a></li></ul></li><li><span class="tocitem">8 Volume Rendering</span><ul><li><a class="tocitem" href="../paraview/paraview_intro/">Intro</a></li><li><a class="tocitem" href="../paraview/08_hydro_VTK_export/">Hydro</a></li><li><a class="tocitem" href="../paraview/08_particles_VTK_export/">Particles</a></li><li><a class="tocitem" href="../api/volume_rendering/">API Reference</a></li></ul></li><li><span class="tocitem">9 Miscellaneous</span><ul><li><a class="tocitem" href="../Miscellaneous/">Tutorial</a></li><li><a class="tocitem" href="../api/miscellaneous/">API Reference</a></li></ul></li><li><span class="tocitem">10 Examples</span><ul><li><a class="tocitem" href="../examples/">Tutorial</a></li><li><a class="tocitem" href="../api/examples/">API Reference</a></li></ul></li><li><span class="tocitem">11 Multi-Threading</span><ul><li><a class="tocitem" href="../multi-threading/multi-threading_intro/">Tutorial</a></li><li><a class="tocitem" href="../api/multithreading/">API Reference</a></li></ul></li><li><span class="tocitem">12 Notifications</span><ul><li><a class="tocitem" href="../notifications/">Overview</a></li><li><a class="tocitem" href="../notifications/bell/">Bell (Local Audio)</a></li><li><a class="tocitem" href="../notifications/email/">Email</a></li><li><a class="tocitem" href="../notifications/zulip/">Zulip (Team Chat)</a></li><li><a class="tocitem" href="../api/notifications/">API Reference</a></li></ul></li><li><span class="tocitem">13 Benchmarks</span><ul><li><a class="tocitem" href="../benchmarks/IO/IOperformance/">Server IO</a></li><li><a class="tocitem" href="../benchmarks/RAMSES_reading/ramses_reading/">Parallel RAMSES-Files Reading</a></li><li><a class="tocitem" href="../benchmarks/JLD2_reading/Mera_files_reading/">Mera-Files Reading</a></li><li><a class="tocitem" href="../benchmarks/Projection/multi_projections/">Parallel Projections</a></li></ul></li><li><span class="tocitem">14 Julia Quick Reference</span><ul><li><a class="tocitem" href="../quickreference/01_getting_started/">Getting Started</a></li><li><a class="tocitem" href="../quickreference/02_migrators/">From Other Languages</a></li><li><a class="tocitem" href="../quickreference/03_packages/">Essential Packages</a></li><li><a class="tocitem" href="../quickreference/04_mera_patterns/">Julia Fundamentals</a></li><li><a class="tocitem" href="../quickreference/05_performance/">Performance &amp; Debugging</a></li><li><a class="tocitem" href="../quickreference/06_resources/">Resources &amp; Community</a></li></ul></li><li><a class="tocitem" href="../api/">15 Complete API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">5 Mask/Filter/Meta</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Masking,-Filtering,-and-Metaprogramming"><a class="docs-heading-anchor" href="#Data-Masking,-Filtering,-and-Metaprogramming">Data Masking, Filtering, and Metaprogramming</a><a id="Data-Masking,-Filtering,-and-Metaprogramming-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Masking,-Filtering,-and-Metaprogramming" title="Permalink"></a></h1><h2 id="Advanced-Data-Manipulation-and-Selection-Techniques"><a class="docs-heading-anchor" href="#Advanced-Data-Manipulation-and-Selection-Techniques">Advanced Data Manipulation and Selection Techniques</a><a id="Advanced-Data-Manipulation-and-Selection-Techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Data-Manipulation-and-Selection-Techniques" title="Permalink"></a></h2><h3 id="Tutorial-Overview"><a class="docs-heading-anchor" href="#Tutorial-Overview">Tutorial Overview</a><a id="Tutorial-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-Overview" title="Permalink"></a></h3><p>This comprehensive tutorial explores the sophisticated data manipulation capabilities within <strong>MERA.jl</strong>, focusing on:</p><ul><li><strong>Data Selection &amp; Extraction</strong>: Advanced techniques for extracting specific variables and columns from complex astrophysical datasets</li><li><strong>Conditional Filtering</strong>: Multi-criteria filtering operations using both IndexedTables.jl and MERA&#39;s custom macros</li><li><strong>Masking Operations</strong>: Boolean array operations for selective data analysis without modifying source tables</li><li><strong>Data Table Extension</strong>: Adding computed variables and derived quantities to existing datasets</li><li><strong>Metaprogramming</strong>: Using MERA&#39;s pipeline macros (@filter, @apply, @where) for elegant data processing workflows</li></ul><h3 id="Learning-Objectives"><a class="docs-heading-anchor" href="#Learning-Objectives">Learning Objectives</a><a id="Learning-Objectives-1"></a><a class="docs-heading-anchor-permalink" href="#Learning-Objectives" title="Permalink"></a></h3><p>By completing this tutorial, you will master:</p><ol><li><p><strong>Data Selection Techniques</strong>:</p><ul><li>Extract single and multiple columns using IndexedTables and MERA functions</li><li>Understanding the difference between <code>select()</code>, <code>columns()</code>, and <code>getvar()</code> approaches</li><li>Working with named tuples and dictionaries for multi-variable extraction</li></ul></li><li><p><strong>Advanced Filtering Operations</strong>:</p><ul><li>Single and multi-condition filtering using IndexedTables syntax</li><li>MERA&#39;s pipeline macros for streamlined data processing</li><li>Creating custom filtering functions for complex geometric conditions</li><li>Comparing performance between different filtering approaches</li></ul></li><li><p><strong>Masking and Boolean Operations</strong>:</p><ul><li>Creating boolean masks for selective analysis</li><li>Combining multiple masks using logical operations</li><li>Applying masks to statistical functions without data modification</li><li>Understanding mask types: Array{Bool,1} vs BitArray{1}</li></ul></li><li><p><strong>Data Table Extension</strong>:</p><ul><li>Adding computed columns using <code>transform()</code> and <code>insertcolsafter()</code></li><li>Managing derived quantities with proper unit handling</li><li>Removing and modifying existing columns</li></ul></li><li><p><strong>Metaprogramming Workflows</strong>:</p><ul><li>Using @filter macro for elegant condition-based filtering</li><li>Building complex filtering pipelines with @apply and @where</li><li>Creating reusable filtering expressions</li></ul></li></ol><h3 id="Technical-Foundation"><a class="docs-heading-anchor" href="#Technical-Foundation">Technical Foundation</a><a id="Technical-Foundation-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Foundation" title="Permalink"></a></h3><h4 id="IndexedTables.jl-Integration"><a class="docs-heading-anchor" href="#IndexedTables.jl-Integration">IndexedTables.jl Integration</a><a id="IndexedTables.jl-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#IndexedTables.jl-Integration" title="Permalink"></a></h4><p>MERA leverages <strong>IndexedTables.jl</strong> for high-performance data manipulation:</p><ul><li><strong>Memory Efficiency</strong>: Column-oriented storage optimized for large datasets</li><li><strong>Type Safety</strong>: Strongly typed columns ensuring computational correctness</li><li><strong>Performance</strong>: Optimized operations for filtering and selection</li><li><strong>Composability</strong>: Chainable operations for complex data processing workflows</li></ul><h4 id="MERA&#39;s-Custom-Macros"><a class="docs-heading-anchor" href="#MERA&#39;s-Custom-Macros">MERA&#39;s Custom Macros</a><a id="MERA&#39;s-Custom-Macros-1"></a><a class="docs-heading-anchor-permalink" href="#MERA&#39;s-Custom-Macros" title="Permalink"></a></h4><p>The tutorial demonstrates MERA&#39;s specialized macros:</p><ul><li><strong>@filter</strong>: Streamlined conditional filtering with automatic type handling</li><li><strong>@apply</strong>: Pipeline operator for chaining multiple filtering operations</li><li><strong>@where</strong>: Condition-based row selection with field reference transformation</li></ul><h4 id="Data-Types-and-Structures"><a class="docs-heading-anchor" href="#Data-Types-and-Structures">Data Types and Structures</a><a id="Data-Types-and-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Types-and-Structures" title="Permalink"></a></h4><p>Key concepts covered:</p><ul><li><strong>DataSetType objects</strong>: HydroDataType, PartDataType, ClumpDataType, GravDataType</li><li><strong>Unit Management</strong>: Automatic conversion between code units and physical units</li><li><strong>Mask Types</strong>: Boolean arrays for selective operations</li><li><strong>Filtered Tables</strong>: Creating new DataSetType objects from filtered data</li></ul><h2 id="Data-Loading-and-Environment-Setup"><a class="docs-heading-anchor" href="#Data-Loading-and-Environment-Setup">Data Loading and Environment Setup</a><a id="Data-Loading-and-Environment-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Loading-and-Environment-Setup" title="Permalink"></a></h2><h3 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h3><p>This section establishes our computational environment by loading simulation data from multiple physics modules. We&#39;ll work with:</p><ul><li><strong>Hydro data</strong>: Gas properties (density, velocity, pressure)</li><li><strong>Particle data</strong>: Stellar and dark matter particles</li><li><strong>Clump data</strong>: Identified density structures</li><li><strong>Simulation metadata</strong>: Physical scales and units</li></ul><h3 id="Data-Loading-Strategy"><a class="docs-heading-anchor" href="#Data-Loading-Strategy">Data Loading Strategy</a><a id="Data-Loading-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Loading-Strategy" title="Permalink"></a></h3><p>For this tutorial, we load data with specific constraints to optimize memory usage while maintaining sufficient complexity for filtering demonstrations:</p><ul><li><strong>Resolution limit</strong>: <code>lmax=8</code> provides good spatial resolution without excessive memory usage</li><li><strong>Small value handling</strong>: <code>smallr=1e-5</code> prevents numerical issues with very low density regions</li><li><strong>Multi-physics approach</strong>: Loading all data types demonstrates cross-component filtering</li></ul><pre><code class="language-julia hljs">using Mera
info = getinfo(400, &quot;/Volumes/FASTStorage/Simulations/Mera-Tests/manu_sim_sf_L14&quot;);
gas       = gethydro(info, lmax=8, smallr=1e-5);
particles = getparticles(info)
clumps    = getclumps(info);</code></pre><pre><code class="nohighlight hljs">[Mera]: 2025-08-14T14:49:55.275

Code: RAMSES
output [400] summary:
mtime: 2018-09-05T09:51:55
ctime: 2025-06-29T20:06:45.267
=======================================================
simulation time: 594.98 [Myr]
boxlen: 48.0 [kpc]
ncpu: 2048
ndim: 3
-------------------------------------------------------
amr:           true
level(s): 6 - 14 --&gt; cellsize(s): 750.0 [pc] - 2.93 [pc]
-------------------------------------------------------
hydro:         true
hydro-variables:  7  --&gt; (:rho, :vx, :vy, :vz, :p, :var6, :var7)
hydro-descriptor: (:density, :velocity_x, :velocity_y, :velocity_z, :thermal_pressure, :passive_scalar_1, :passive_scalar_2)
γ: 1.6667
-------------------------------------------------------
gravity:       true
gravity-variables: (:epot, :ax, :ay, :az)
-------------------------------------------------------
particles:     true
- Npart:    5.091500e+05
- Nstars:   5.066030e+05
- Ndm:      2.547000e+03
particle-variables: 5  --&gt; (:vx, :vy, :vz, :mass, :birth)
-------------------------------------------------------
rt:            false
-------------------------------------------------------
clumps:           true
clump-variables: (:index, :lev, :parent, :ncell, :peak_x, :peak_y, :peak_z, Symbol(&quot;rho-&quot;), Symbol(&quot;rho+&quot;), :rho_av, :mass_cl, :relevance)
-------------------------------------------------------
namelist-file:    false
timer-file:       false
compilation-file: true
makefile:         true
patchfile:        true
=======================================================

[Mera]: Get hydro data: 2025-08-14T14:49:57.658

Key vars=(:level, :cx, :cy, :cz)
Using var(s)=(1, 2, 3, 4, 5, 6, 7) = (:rho, :vx, :vy, :vz, :p, :var6, :var7)

domain:
xmin::xmax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]
ymin::ymax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]
zmin::zmax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]

📊 Processing Configuration:
   Total CPU files available: 2048
   Files to be processed: 2048
   Compute threads: 1
   GC threads: 1
</code></pre><pre><code class="nohighlight hljs">Processing files: 100%|██████████████████████████████████████████████████| Time: 0:02:47 (81.74 ms/it)
</code></pre><pre><code class="nohighlight hljs">
✓ File processing complete! Combining results...
✓ Data combination complete!
Final data size: 849332 cells, 7 variables
Creating Table from 849332 cells with max 1 threads...
  Threading: 1 threads for 11 columns
  Max threads requested: 1
  Available threads: 1
  Using sequential processing (optimal for small datasets)
  Creating IndexedTable with 11 columns...
  0.741037 seconds (4.93 M allocations: 465.695 MiB, 4.69% gc time, 89.64% compilation time)
✓ Table created in 1.086 seconds
Memory used for data table :71.27991771697998 MB
-------------------------------------------------------

[Mera]: Get particle data: 2025-08-14T14:52:49.720

Key vars=(:level, :x, :y, :z, :id)
Using var(s)=(1, 2, 3, 4, 5) = (:vx, :vy, :vz, :mass, :birth)

domain:
xmin::xmax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]
ymin::ymax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]
zmin::zmax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]
</code></pre><pre><code class="nohighlight hljs">Progress: 100%|█████████████████████████████████████████| Time: 0:00:12
</code></pre><pre><code class="nohighlight hljs">Found 5.089390e+05 particles
Memory used for data table :34.94713020324707 MB
-------------------------------------------------------

[Mera]: Get clump data: 2025-08-14T14:53:03.207

domain:
xmin::xmax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]
ymin::ymax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]
zmin::zmax: 0.0 :: 1.0  	==&gt; 0.0 [kpc] :: 48.0 [kpc]

Read 12 colums:
[:index, :lev, :parent, :ncell, :peak_x, :peak_y, :peak_z, Symbol(&quot;rho-&quot;), Symbol(&quot;rho+&quot;), :rho_av, :mass_cl, :relevance]
Memory used for data table :61.58203125 KB
-------------------------------------------------------
</code></pre><h2 id="Data-Selection-from-Tables"><a class="docs-heading-anchor" href="#Data-Selection-from-Tables">Data Selection from Tables</a><a id="Data-Selection-from-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Selection-from-Tables" title="Permalink"></a></h2><h3 id="Overview-2"><a class="docs-heading-anchor" href="#Overview-2">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-2" title="Permalink"></a></h3><p>Data selection is the foundation of all filtering and analysis operations in MERA. This section demonstrates multiple approaches to extract variables and columns from simulation datasets, each optimized for different use cases.</p><h3 id="Selection-Methodologies"><a class="docs-heading-anchor" href="#Selection-Methodologies">Selection Methodologies</a><a id="Selection-Methodologies-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-Methodologies" title="Permalink"></a></h3><p>We&#39;ll explore three complementary approaches:</p><ol><li><p><strong>IndexedTables.jl Functions</strong> (<code>select</code>, <code>columns</code>):</p><ul><li>Direct table operations with maximum performance</li><li>Returns raw arrays or new table structures</li><li>Ideal for bulk data extraction and preprocessing</li></ul></li><li><p><strong>MERA Functions</strong> (<code>getvar</code>):</p><ul><li>Integrated unit conversion and derived quantity calculation</li><li>Handles physical units automatically</li><li>Supports filtered datasets and custom data types</li></ul></li><li><p><strong>Hybrid Approaches</strong>:</p><ul><li>Combining both methods for optimal workflow</li><li>Performance comparison and selection criteria</li><li>Best practices for large dataset handling</li></ul></li></ol><h3 id="Key-Concepts"><a class="docs-heading-anchor" href="#Key-Concepts">Key Concepts</a><a id="Key-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts" title="Permalink"></a></h3><ul><li><strong>Column-oriented access</strong>: IndexedTables stores data by column for efficient selection</li><li><strong>Type preservation</strong>: All operations maintain proper data types</li><li><strong>Memory efficiency</strong>: Selection creates views when possible, not copies</li><li><strong>Unit handling</strong>: MERA functions automatically manage unit conversions</li></ul><h3 id="Single-Column/Variable-Selection"><a class="docs-heading-anchor" href="#Single-Column/Variable-Selection">Single Column/Variable Selection</a><a id="Single-Column/Variable-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Column/Variable-Selection" title="Permalink"></a></h3><h4 id="Method-Comparison:-IndexedTables-vs-MERA"><a class="docs-heading-anchor" href="#Method-Comparison:-IndexedTables-vs-MERA">Method Comparison: IndexedTables vs MERA</a><a id="Method-Comparison:-IndexedTables-vs-MERA-1"></a><a class="docs-heading-anchor-permalink" href="#Method-Comparison:-IndexedTables-vs-MERA" title="Permalink"></a></h4><p><strong>IndexedTables Approach</strong> (<code>select</code>):</p><ul><li><strong>Performance</strong>: Maximum speed for raw data extraction</li><li><strong>Output</strong>: Vector{Float64} with data in code units</li><li><strong>Use case</strong>: When you need raw numerical data for custom calculations</li><li><strong>Memory</strong>: Most efficient, creates minimal overhead</li></ul><p><strong>MERA Approach</strong> (<code>getvar</code>):</p><ul><li><strong>Functionality</strong>: Supports derived quantities and unit conversions</li><li><strong>Output</strong>: Vector with automatic unit conversion available</li><li><strong>Use case</strong>: When you need physical quantities or derived variables</li><li><strong>Integration</strong>: Seamlessly works with other MERA functions</li></ul><h5 id="By-using-IndexedTables-or-Mera-functions"><a class="docs-heading-anchor" href="#By-using-IndexedTables-or-Mera-functions">By using IndexedTables or Mera functions</a><a id="By-using-IndexedTables-or-Mera-functions-1"></a><a class="docs-heading-anchor-permalink" href="#By-using-IndexedTables-or-Mera-functions" title="Permalink"></a></h5><pre><code class="language-julia hljs">using Mera.IndexedTables</code></pre><p>The data table is stored in the <code>data</code>-field of any <code>DataSetType</code>. Extract an existing column (variable):</p><pre><code class="language-julia hljs">select(gas.data, :rho) # IndexedTables</code></pre><pre><code class="nohighlight hljs">849332-element Vector{Float64}:
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 ⋮
 0.00010967104288285959
 0.0001088040126114162
 0.00010915603617815434
 0.00010917096551347797
 0.00012465438542871006
 0.00011934527871880502
 0.00011294656300014925
 0.00011110068692986109
 0.00010901341218606515
 0.00010849404903183988
 0.00010900588395976569
 0.00010910219163333514</code></pre><p>Pass the entire <code>DataSetType</code> (here <code>gas</code>) to the Mera function <code>getvar</code> to extract the selected variable or derived quantity from the data table. Call <code>getvar()</code> to get a list of the predefined quantities.</p><pre><code class="language-julia hljs">getvar(gas, :rho) # MERA</code></pre><pre><code class="nohighlight hljs">849332-element Vector{Float64}:
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 ⋮
 0.00010967104288285959
 0.0001088040126114162
 0.00010915603617815434
 0.00010917096551347797
 0.00012465438542871006
 0.00011934527871880502
 0.00011294656300014925
 0.00011110068692986109
 0.00010901341218606515
 0.00010849404903183988
 0.00010900588395976569
 0.00010910219163333514</code></pre><h3 id="Select-several-columns"><a class="docs-heading-anchor" href="#Select-several-columns">Select several columns</a><a id="Select-several-columns-1"></a><a class="docs-heading-anchor-permalink" href="#Select-several-columns" title="Permalink"></a></h3><p>By selecting several columns a new data table is returned:</p><pre><code class="language-julia hljs">select(gas.data, (:rho, :level)) # IndexedTables</code></pre><pre><code class="nohighlight hljs">Table with 849332 rows, 2 columns:
rho          level
──────────────────
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
1.0e-5       6
⋮
0.000108804  8
0.000109156  8
0.000109171  8
0.000124654  8
0.000119345  8
0.000112947  8
0.000111101  8
0.000109013  8
0.000108494  8
0.000109006  8
0.000109102  8</code></pre><p>The getvar function returns a dictionary containing the extracted arrays:</p><pre><code class="language-julia hljs">getvar(gas, [:rho, :level]) # MERA</code></pre><pre><code class="nohighlight hljs">Dict{Any, Any} with 2 entries:
  :level =&gt; [6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0  …  8.0, 8.0, 8.0…
  :rho   =&gt; [1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.…</code></pre><p>Select one or more columns and get a tuple of vectors:</p><pre><code class="language-julia hljs">vtuple = columns(gas.data, (:rho, :level)) # IndexedTables</code></pre><pre><code class="nohighlight hljs">(rho = [1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5, 1.0e-5  …  0.00010915603617815434, 0.00010917096551347797, 0.00012465438542871006, 0.00011934527871880502, 0.00011294656300014925, 0.00011110068692986109, 0.00010901341218606515, 0.00010849404903183988, 0.00010900588395976569, 0.00010910219163333514], level = [6, 6, 6, 6, 6, 6, 6, 6, 6, 6  …  8, 8, 8, 8, 8, 8, 8, 8, 8, 8])</code></pre><pre><code class="language-julia hljs">propertynames(vtuple)</code></pre><pre><code class="nohighlight hljs">(:rho, :level)</code></pre><pre><code class="language-julia hljs">vtuple.rho</code></pre><pre><code class="nohighlight hljs">849332-element Vector{Float64}:
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 1.0e-5
 ⋮
 0.00010967104288285959
 0.0001088040126114162
 0.00010915603617815434
 0.00010917096551347797
 0.00012465438542871006
 0.00011934527871880502
 0.00011294656300014925
 0.00011110068692986109
 0.00010901341218606515
 0.00010849404903183988
 0.00010900588395976569
 0.00010910219163333514</code></pre><h3 id="Multiple-Column-Selection"><a class="docs-heading-anchor" href="#Multiple-Column-Selection">Multiple Column Selection</a><a id="Multiple-Column-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-Column-Selection" title="Permalink"></a></h3><h4 id="Data-Structure-Comparison"><a class="docs-heading-anchor" href="#Data-Structure-Comparison">Data Structure Comparison</a><a id="Data-Structure-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structure-Comparison" title="Permalink"></a></h4><p><strong>IndexedTables <code>select</code> Output</strong>:</p><ul><li>Returns a new <code>Table</code> object with selected columns</li><li>Maintains column relationships and indexing</li><li>Efficient for subsequent filtering operations</li><li>Memory overhead: Only stores references to selected columns</li></ul><p><strong>IndexedTables <code>columns</code> Output</strong>:</p><ul><li>Returns <code>NamedTuple</code> of vectors</li><li>Direct access to individual arrays via dot notation</li><li>Best for mathematical operations on multiple variables</li><li>Memory: Slightly higher due to tuple structure</li></ul><p><strong>MERA <code>getvar</code> Output</strong>:</p><ul><li>Returns <code>Dictionary</code> with flexible key-value access</li><li>Supports mixed units and derived quantities</li><li>Ideal for complex analysis workflows</li><li>Memory: Additional overhead for unit management</li></ul><h4 id="Use-Case-Guidelines"><a class="docs-heading-anchor" href="#Use-Case-Guidelines">Use Case Guidelines</a><a id="Use-Case-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Case-Guidelines" title="Permalink"></a></h4><ul><li><strong>Table selection</strong>: When maintaining relational structure for filtering</li><li><strong>Column tuples</strong>: For mathematical operations requiring multiple variables</li><li><strong>Dictionary extraction</strong>: When working with different units or derived quantities</li></ul><h2 id="Filter-by-Condition"><a class="docs-heading-anchor" href="#Filter-by-Condition">Filter by Condition</a><a id="Filter-by-Condition-1"></a><a class="docs-heading-anchor-permalink" href="#Filter-by-Condition" title="Permalink"></a></h2><h3 id="With-IndexedTables-(example-A)"><a class="docs-heading-anchor" href="#With-IndexedTables-(example-A)">With IndexedTables (example A)</a><a id="With-IndexedTables-(example-A)-1"></a><a class="docs-heading-anchor-permalink" href="#With-IndexedTables-(example-A)" title="Permalink"></a></h3><p>Get all the data corresponding to cells/rows with level=6. Here, the variable <code>p</code> is used as placeholder for rows. A new IndexedTables data table is returend:</p><pre><code class="language-julia hljs">filtered_db = filter(p-&gt;p.level==6, gas.data ) # IndexedTables
# see the reduced row number</code></pre><pre><code class="nohighlight hljs">Table with 240956 rows, 11 columns:
Columns:
#   colname  type
────────────────────
1   level    Int64
2   cx       Int64
3   cy       Int64
4   cz       Int64
5   rho      Float64
6   vx       Float64
7   vy       Float64
8   vz       Float64
9   p        Float64
10  var6     Float64
11  var7     Float64</code></pre><h3 id="With-IndexedTables-(example-B)"><a class="docs-heading-anchor" href="#With-IndexedTables-(example-B)">With IndexedTables (example B)</a><a id="With-IndexedTables-(example-B)-1"></a><a class="docs-heading-anchor-permalink" href="#With-IndexedTables-(example-B)" title="Permalink"></a></h3><p>Get all cells/rows with densities &gt;= 3 Msol/pc^3. Since the data is given in code units, we need to convert from the given physical units:</p><pre><code class="language-julia hljs">density = 3. / gas.scale.Msol_pc3
filtered_db = filter(p-&gt;p.rho&gt;= density, gas.data ) # IndexedTables</code></pre><pre><code class="nohighlight hljs">Table with 210 rows, 11 columns:
Columns:
#   colname  type
────────────────────
1   level    Int64
2   cx       Int64
3   cy       Int64
4   cz       Int64
5   rho      Float64
6   vx       Float64
7   vy       Float64
8   vz       Float64
9   p        Float64
10  var6     Float64
11  var7     Float64</code></pre><h3 id="Unit-Conversion-in-Filtering"><a class="docs-heading-anchor" href="#Unit-Conversion-in-Filtering">Unit Conversion in Filtering</a><a id="Unit-Conversion-in-Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Conversion-in-Filtering" title="Permalink"></a></h3><p><strong>Critical Concept</strong>: All data in MERA tables is stored in <strong>code units</strong>, not physical units.</p><p><strong>Before filtering</strong>, always convert your physical threshold to code units:</p><pre><code class="language-julia hljs"># Convert physical density (3 Msol/pc³) to code units
density_physical = 3.0  # Msol/pc³
density_code = density_physical / gas.scale.Msol_pc3</code></pre><p><strong>Why this matters</strong>:</p><ul><li>Direct comparison with physical values will fail: <code>row.rho &gt;= 3.0</code> (incorrect)</li><li>Correct comparison uses code units: <code>row.rho &gt;= density_code</code> (correct)</li><li>MERA&#39;s <code>.scale</code> properties provide all necessary conversion factors</li></ul><p><strong>Performance tip</strong>: Pre-calculate conversion factors once, reuse in filter conditions.</p><h3 id="Get-a-Quantity/Variable-from-The-Filtered-Data-Table"><a class="docs-heading-anchor" href="#Get-a-Quantity/Variable-from-The-Filtered-Data-Table">Get a Quantity/Variable from The Filtered Data Table</a><a id="Get-a-Quantity/Variable-from-The-Filtered-Data-Table-1"></a><a class="docs-heading-anchor-permalink" href="#Get-a-Quantity/Variable-from-The-Filtered-Data-Table" title="Permalink"></a></h3><p>Calculate the mass for each cell and the sum:</p><pre><code class="language-julia hljs">mass_tot = getvar(gas, :mass, :Msol) # the full data table
sum(mass_tot)</code></pre><pre><code class="nohighlight hljs">3.0968754148332745e10</code></pre><p>The same calculation is possible for the filtered data base which has to be passed together with the original object, here: <code>gas</code></p><pre><code class="language-julia hljs">mass_filtered_tot = getvar(gas, :mass, :Msol, filtered_db=filtered_db) # the filtered data table
sum(mass_filtered_tot)</code></pre><pre><code class="nohighlight hljs">1.4862767967535206e10</code></pre><h2 id="Conditional-Data-Filtering"><a class="docs-heading-anchor" href="#Conditional-Data-Filtering">Conditional Data Filtering</a><a id="Conditional-Data-Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Conditional-Data-Filtering" title="Permalink"></a></h2><h3 id="Overview-3"><a class="docs-heading-anchor" href="#Overview-3">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-3" title="Permalink"></a></h3><p>Filtering enables selective data analysis by creating subsets based on specific conditions. MERA supports multiple filtering approaches, each optimized for different complexity levels and performance requirements.</p><h3 id="Filtering-Methodologies"><a class="docs-heading-anchor" href="#Filtering-Methodologies">Filtering Methodologies</a><a id="Filtering-Methodologies-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-Methodologies" title="Permalink"></a></h3><ol><li><p><strong>IndexedTables Native Filtering</strong>:</p><ul><li>Uses <code>filter(condition_function, table)</code> syntax</li><li>Highest performance for simple conditions</li><li>Returns new table structure with filtered rows</li><li>Memory efficient through lazy evaluation</li></ul></li><li><p><strong>MERA Macro Filtering</strong>:</p><ul><li>Custom <code>@filter</code> macro for streamlined syntax</li><li>Automatic type handling and unit conversion</li><li>Supports complex expressions with field references</li><li>Optimized for astrophysical data patterns</li></ul></li><li><p><strong>Chained Filtering</strong>:</p><ul><li>Sequential application of multiple conditions</li><li>Pipeline-style operations for complex criteria</li><li>Progressive refinement of datasets</li></ul></li></ol><h3 id="Performance-Considerations"><a class="docs-heading-anchor" href="#Performance-Considerations">Performance Considerations</a><a id="Performance-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Considerations" title="Permalink"></a></h3><ul><li><strong>Simple conditions</strong>: IndexedTables native filtering is fastest</li><li><strong>Complex expressions</strong>: MERA macros provide better readability</li><li><strong>Multiple conditions</strong>: Chain operations for optimal memory usage</li><li><strong>Large datasets</strong>: Consider filtering before expensive calculations</li></ul><h2 id="Create-a-New-DataSetType-from-a-Filtered-Data-Table"><a class="docs-heading-anchor" href="#Create-a-New-DataSetType-from-a-Filtered-Data-Table">Create a New DataSetType from a Filtered Data Table</a><a id="Create-a-New-DataSetType-from-a-Filtered-Data-Table-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-New-DataSetType-from-a-Filtered-Data-Table" title="Permalink"></a></h2><p>The macros @filter is created by Mera and are not included in IndexedTables.jl.</p><p>A new <code>DataSetType</code> can be constructed for the filtered data table that can be passed to the functions.</p><pre><code class="language-julia hljs">density = 3. /gas.scale.Msol_pc3
filtered_db = @filter gas.data :rho &gt;= density
gas_new = construct_datatype(filtered_db, gas);</code></pre><pre><code class="language-julia hljs"># Both are now of HydroDataType and include the same information about the simulation properties (besides the canged data table)
println( typeof(gas) )
println( typeof(gas_new) )</code></pre><pre><code class="nohighlight hljs">HydroDataType
HydroDataType
</code></pre><pre><code class="language-julia hljs">mass_filtered_tot = getvar(gas_new, :mass, :Msol)
sum(mass_filtered_tot)</code></pre><pre><code class="nohighlight hljs">1.4862767967535206e10</code></pre><h2 id="Multi-Criteria-Filtering"><a class="docs-heading-anchor" href="#Multi-Criteria-Filtering">Multi-Criteria Filtering</a><a id="Multi-Criteria-Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Criteria-Filtering" title="Permalink"></a></h2><h3 id="Advanced-Filtering-Strategies"><a class="docs-heading-anchor" href="#Advanced-Filtering-Strategies">Advanced Filtering Strategies</a><a id="Advanced-Filtering-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Filtering-Strategies" title="Permalink"></a></h3><p>Multi-condition filtering enables sophisticated data selection by combining multiple criteria. This section demonstrates various approaches for handling complex geometric and physical constraints.</p><h3 id="Filtering-Approaches-Comparison"><a class="docs-heading-anchor" href="#Filtering-Approaches-Comparison">Filtering Approaches Comparison</a><a id="Filtering-Approaches-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-Approaches-Comparison" title="Permalink"></a></h3><h4 id="1.-**Sequential-IndexedTables-Filtering**"><a class="docs-heading-anchor" href="#1.-**Sequential-IndexedTables-Filtering**">1. <strong>Sequential IndexedTables Filtering</strong></a><a id="1.-**Sequential-IndexedTables-Filtering**-1"></a><a class="docs-heading-anchor-permalink" href="#1.-**Sequential-IndexedTables-Filtering**" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Step-by-step refinement
filtered_db = filter(p-&gt;p.rho &gt;= density, gas.data)
filtered_db = filter(row-&gt;geometric_condition(row), filtered_db)</code></pre><p><strong>Advantages</strong>: Clear logical flow, easy debugging, memory efficient <strong>Use case</strong>: When conditions have different computational costs</p><h4 id="2.-**Combined-Condition-Filtering**"><a class="docs-heading-anchor" href="#2.-**Combined-Condition-Filtering**">2. <strong>Combined Condition Filtering</strong></a><a id="2.-**Combined-Condition-Filtering**-1"></a><a class="docs-heading-anchor-permalink" href="#2.-**Combined-Condition-Filtering**" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Single filter with compound condition
filtered_db = filter(row-&gt; condition1 &amp;&amp; condition2 &amp;&amp; condition3, gas.data)</code></pre><p><strong>Advantages</strong>: Single pass through data, optimal performance <strong>Use case</strong>: When all conditions have similar computational requirements</p><h4 id="3.-**MERA-Pipeline-Macros**"><a class="docs-heading-anchor" href="#3.-**MERA-Pipeline-Macros**">3. <strong>MERA Pipeline Macros</strong></a><a id="3.-**MERA-Pipeline-Macros**-1"></a><a class="docs-heading-anchor-permalink" href="#3.-**MERA-Pipeline-Macros**" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Elegant pipeline syntax
filtered_db = @apply gas.data begin
    @where :rho &gt;= density
    @where geometric_condition
end</code></pre><p><strong>Advantages</strong>: Readable syntax, automatic optimization, extensible <strong>Use case</strong>: Complex analysis workflows with many conditions</p><h3 id="Geometric-Filtering-Techniques"><a class="docs-heading-anchor" href="#Geometric-Filtering-Techniques">Geometric Filtering Techniques</a><a id="Geometric-Filtering-Techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Filtering-Techniques" title="Permalink"></a></h3><p>This section demonstrates <strong>cylindrical selection</strong> - a common astrophysical analysis pattern for studying disk galaxies, outflows, and rotating structures.</p><h3 id="With-IndexedTables"><a class="docs-heading-anchor" href="#With-IndexedTables">With IndexedTables</a><a id="With-IndexedTables-1"></a><a class="docs-heading-anchor-permalink" href="#With-IndexedTables" title="Permalink"></a></h3><p>Get the mass of all cells/rows with densities &gt;= 3 Msol/pc^3 that is within the disk radius of 3 kpc and 2 kpc from the plane:</p><pre><code class="language-julia hljs">boxlen = info.boxlen
cv = boxlen/2. # box-center
density = 3. /gas.scale.Msol_pc3
radius  = 3. /gas.scale.kpc
height  = 2. /gas.scale.kpc

# filter cells/rows that contain rho greater equal density
filtered_db = filter(p-&gt;p.rho &gt;= density, gas.data )

# filter cells/rows lower equal the defined radius and height
# (convert the cell number to a position according to its cellsize and relative to the box center)
filtered_db = filter(row-&gt; sqrt( (row.cx * boxlen /2^row.level - cv)^2 + (row.cy * boxlen /2^row.level - cv)^2) &lt;= radius &amp;&amp;
                              abs(row.cz * boxlen /2^row.level - cv) &lt;= height, filtered_db)

var_filtered = getvar(gas, :mass, filtered_db=filtered_db, unit=:Msol)
sum(var_filtered) # [Msol]</code></pre><pre><code class="nohighlight hljs">2.7506324500621886e9</code></pre><h3 id="Use-Pipeline-Macros"><a class="docs-heading-anchor" href="#Use-Pipeline-Macros">Use Pipeline Macros</a><a id="Use-Pipeline-Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Pipeline-Macros" title="Permalink"></a></h3><p>The macros @apply and @where are created by Mera and are not included in IndexedTables.jl.</p><pre><code class="language-julia hljs">boxlen = info.boxlen
cv = boxlen/2.
density = 3. /gas.scale.Msol_pc3
radius  = 3. /gas.scale.kpc
height  = 2. /gas.scale.kpc

filtered_db = @apply gas.data begin
     @where :rho &gt;= density
     @where sqrt( (:cx * boxlen/2^:level - cv)^2 + (:cy * boxlen/2^:level - cv)^2 ) &lt;= radius
     @where abs(:cz * boxlen/2^:level -cv) &lt;= height
end

var_filtered = getvar(gas, :mass, filtered_db=filtered_db, unit=:Msol)
sum(var_filtered) # [Msol]</code></pre><pre><code class="nohighlight hljs">2.7506324500621886e9</code></pre><h3 id="External-Functions-With-IndexedTables"><a class="docs-heading-anchor" href="#External-Functions-With-IndexedTables">External Functions With IndexedTables</a><a id="External-Functions-With-IndexedTables-1"></a><a class="docs-heading-anchor-permalink" href="#External-Functions-With-IndexedTables" title="Permalink"></a></h3><pre><code class="language-julia hljs">boxlen = info.boxlen
function r(x,y,level,boxlen)
    return sqrt((x * boxlen /2^level - boxlen/2.)^2 + (y * boxlen /2^level - boxlen/2.)^2)
end

function h(z,level,boxlen)
    return abs(z  * boxlen /2^level - boxlen/2.)
end

density = 3. /gas.scale.Msol_pc3
radius  = 3. /gas.scale.kpc
height  = 2. /gas.scale.kpc

filtered_db = filter(row-&gt;  row.rho &gt;= density &amp;&amp;
                            r(row.cx,row.cy, row.level, boxlen) &lt;= radius &amp;&amp;
                            h(row.cz,row.level, boxlen) &lt;= height,  gas.data)

var_filtered = getvar(gas, :mass, filtered_db=filtered_db, unit=:Msol)
sum(var_filtered) # [Msol]</code></pre><pre><code class="nohighlight hljs">2.7506324500621886e9</code></pre><p><strong>Result Verification</strong>: All methods produce identical filtered datasets (~2.75e9 Msol total mass), confirming implementation consistency.</p><h3 id="Compare-With-Predefined-Functions"><a class="docs-heading-anchor" href="#Compare-With-Predefined-Functions">Compare With Predefined Functions</a><a id="Compare-With-Predefined-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Compare-With-Predefined-Functions" title="Permalink"></a></h3><p>Compare the previous calculations with the predefined <code>subregion</code> function: The <code>subregion</code> function takes the intersected cells of the range borders into account (default):</p><pre><code class="language-julia hljs">density = 3. /gas.scale.Msol_pc3 # in code units

sub_region = subregion(gas, :cylinder, radius=3., height=2., center=[:boxcenter], range_unit=:kpc, verbose=false ) # default: cell=true
filtered_db = @filter sub_region.data :rho &gt;= density

var_filtered = getvar(gas, :mass, :Msol, filtered_db=filtered_db)
sum(var_filtered) # [Msol]</code></pre><pre><code class="nohighlight hljs">2.9388306102361355e9</code></pre><p>By setting the keyword <code>cell=false</code>, only the cell-centres within the defined region are taken into account (as in the calculations in the previous section).</p><pre><code class="language-julia hljs">density = 3. /gas.scale.Msol_pc3 # in code units

sub_region = subregion(gas, :cylinder, radius=3., height=2., center=[:boxcenter], range_unit=:kpc, cell=false, verbose=false )
filtered_db = @filter sub_region.data :rho &gt;= density

var_filtered = getvar(gas, :mass, :Msol, filtered_db=filtered_db)
sum(var_filtered)</code></pre><pre><code class="nohighlight hljs">2.7506324500621886e9</code></pre><h2 id="Extend-the-Data-Table"><a class="docs-heading-anchor" href="#Extend-the-Data-Table">Extend the Data Table</a><a id="Extend-the-Data-Table-1"></a><a class="docs-heading-anchor-permalink" href="#Extend-the-Data-Table" title="Permalink"></a></h2><p>Add costum columns/variables to the data that can be automatically processed in some functions: (note: to take advantage of the Mera unit management, store new data in code-units)</p><pre><code class="language-julia hljs"># calculate the Mach number in each cell
mach = getvar(gas, :mach);</code></pre><h3 id="Mach-Number-Calculation-Example"><a class="docs-heading-anchor" href="#Mach-Number-Calculation-Example">Mach Number Calculation Example</a><a id="Mach-Number-Calculation-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Mach-Number-Calculation-Example" title="Permalink"></a></h3><p><strong>Physical Significance</strong>: The Mach number (M = v/c_s) is crucial for understanding:</p><ul><li><strong>Turbulence characterization</strong>: Subsonic (M &lt; 1) vs supersonic (M &gt; 1) flows</li><li><strong>Shock wave identification</strong>: High Mach regions indicate strong shocks</li><li><strong>Star formation</strong>: Turbulent support against gravitational collapse</li></ul><p><strong>MERA Implementation</strong>:</p><ul><li><code>getvar(gas, :mach)</code> automatically calculates: M = |v| / c_s</li><li>Handles pressure, density, and velocity conversion to sound speed</li><li>Returns dimensionless quantity (no unit conversion needed)</li></ul><p><strong>Integration Workflow</strong>:</p><ol><li>Calculate derived quantity using MERA functions</li><li>Add to table structure with meaningful name</li><li>Use in subsequent analysis (projections, filtering, statistics)</li></ol><p>This example demonstrates how easily MERA integrates custom calculations into the standard analysis pipeline.</p><pre><code class="language-julia hljs"># add the extracted Mach number (1dim-array) to the data in the object &quot;gas&quot;
# the array has the same length and order (rows/cells) as in the data table
# push a column at the end of the table:
# transform(data-table, key =&gt; new-data)
gas.data = transform(gas.data, :mach =&gt; mach) # IndexedTables</code></pre><pre><code class="nohighlight hljs">Table with 849332 rows, 12 columns:
Columns:
#   colname  type
────────────────────
1   level    Int64
2   cx       Int64
3   cy       Int64
4   cz       Int64
5   rho      Float64
6   vx       Float64
7   vy       Float64
8   vz       Float64
9   p        Float64
10  var6     Float64
11  var7     Float64
12  mach     Float64</code></pre><pre><code class="language-julia hljs">proj_z = projection(gas, :mach, xrange=[-8.,8.], yrange=[-8.,8.], zrange=[-2.,2.], center=[:boxcenter], range_unit=:kpc);</code></pre><pre><code class="nohighlight hljs">[Mera]: 2025-08-14T14:53:11.798

center: [0.5, 0.5, 0.5] ==&gt; [24.0 [kpc] :: 24.0 [kpc] :: 24.0 [kpc]]

domain:
xmin::xmax: 0.3333333 :: 0.6666667  	==&gt; 16.0 [kpc] :: 32.0 [kpc]
ymin::ymax: 0.3333333 :: 0.6666667  	==&gt; 16.0 [kpc] :: 32.0 [kpc]
zmin::zmax: 0.4583333 :: 0.5416667  	==&gt; 22.0 [kpc] :: 26.0 [kpc]

Selected var(s)=(:mach, :sd)
Weighting      = :mass

Effective resolution: 256^2
Map size: 86 x 86
Pixel size: 187.5 [pc]
Simulation min.: 187.5 [pc]

Available threads: 1
Requested max_threads: 1
Variables: 2 (mach, sd)
Processing mode: Sequential (single thread)
</code></pre><pre><code class="language-julia hljs">using PyPlot
imshow( ( permutedims(proj_z.maps[:mach]) ), origin=&quot;lower&quot;, extent=proj_z.cextent)
colorbar();</code></pre><p><img src="../05_multi_Masking_Filtering_files/05_multi_Masking_Filtering_60_1.png" alt/></p><pre><code class="nohighlight hljs">Figure(PyObject &lt;Figure size 640x480 with 2 Axes&gt;)</code></pre><p>Remove the column :mach from the table:</p><pre><code class="language-julia hljs">gas.data = select(gas.data, Not(:mach)) # select all columns, not :mach</code></pre><pre><code class="nohighlight hljs">Table with 849332 rows, 11 columns:
Columns:
#   colname  type
────────────────────
1   level    Int64
2   cx       Int64
3   cy       Int64
4   cz       Int64
5   rho      Float64
6   vx       Float64
7   vy       Float64
8   vz       Float64
9   p        Float64
10  var6     Float64
11  var7     Float64</code></pre><h2 id="Data-Table-Extension-and-Modification"><a class="docs-heading-anchor" href="#Data-Table-Extension-and-Modification">Data Table Extension and Modification</a><a id="Data-Table-Extension-and-Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Table-Extension-and-Modification" title="Permalink"></a></h2><h3 id="Overview-4"><a class="docs-heading-anchor" href="#Overview-4">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-4" title="Permalink"></a></h3><p>Table extension allows you to add computed variables and derived quantities directly to your simulation datasets. This enables seamless integration of custom calculations with MERA&#39;s analysis functions.</p><h3 id="Extension-Methodologies"><a class="docs-heading-anchor" href="#Extension-Methodologies">Extension Methodologies</a><a id="Extension-Methodologies-1"></a><a class="docs-heading-anchor-permalink" href="#Extension-Methodologies" title="Permalink"></a></h3><h4 id="1.-**Transform-Method**-(transform)"><a class="docs-heading-anchor" href="#1.-**Transform-Method**-(transform)">1. <strong>Transform Method</strong> (<code>transform</code>)</a><a id="1.-**Transform-Method**-(transform)-1"></a><a class="docs-heading-anchor-permalink" href="#1.-**Transform-Method**-(transform)" title="Permalink"></a></h4><pre><code class="language-julia hljs">data_table = transform(data_table, :new_column =&gt; calculated_values)</code></pre><ul><li><strong>Purpose</strong>: Add columns to existing tables</li><li><strong>Performance</strong>: Optimized for large datasets</li><li><strong>Memory</strong>: Creates new table structure efficiently</li></ul><h4 id="2.-**Insert-Method**-(insertcolsafter)"><a class="docs-heading-anchor" href="#2.-**Insert-Method**-(insertcolsafter)">2. <strong>Insert Method</strong> (<code>insertcolsafter</code>)</a><a id="2.-**Insert-Method**-(insertcolsafter)-1"></a><a class="docs-heading-anchor-permalink" href="#2.-**Insert-Method**-(insertcolsafter)" title="Permalink"></a></h4><pre><code class="language-julia hljs">data_table = insertcolsafter(data_table, position, :new_column =&gt; values)</code></pre><ul><li><strong>Purpose</strong>: Insert columns at specific positions</li><li><strong>Control</strong>: Precise column ordering</li><li><strong>Use case</strong>: When column order matters for downstream processing</li></ul><h3 id="Best-Practices-for-Table-Extension"><a class="docs-heading-anchor" href="#Best-Practices-for-Table-Extension">Best Practices for Table Extension</a><a id="Best-Practices-for-Table-Extension-1"></a><a class="docs-heading-anchor-permalink" href="#Best-Practices-for-Table-Extension" title="Permalink"></a></h3><h4 id="Unit-Management"><a class="docs-heading-anchor" href="#Unit-Management">Unit Management</a><a id="Unit-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Management" title="Permalink"></a></h4><ul><li><strong>Store in code units</strong>: Maintains consistency with existing data</li><li><strong>Document physical meaning</strong>: Use meaningful column names</li><li><strong>Conversion factors</strong>: Keep physical unit equivalents accessible</li></ul><h4 id="Data-Validation"><a class="docs-heading-anchor" href="#Data-Validation">Data Validation</a><a id="Data-Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Validation" title="Permalink"></a></h4><ul><li><strong>Array length</strong>: New columns must match table row count</li><li><strong>Data types</strong>: Use appropriate numerical types (Float64, Int64)</li><li><strong>Missing values</strong>: Handle edge cases and undefined calculations</li></ul><h4 id="Memory-Considerations"><a class="docs-heading-anchor" href="#Memory-Considerations">Memory Considerations</a><a id="Memory-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Considerations" title="Permalink"></a></h4><ul><li><strong>In-place operations</strong>: When possible, use <code>transform</code> for efficiency</li><li><strong>Temporary calculations</strong>: Clean up intermediate arrays</li><li><strong>Large datasets</strong>: Consider computing on-demand vs storing all derived quantities</li></ul><h2 id="Data-Masking-Operations"><a class="docs-heading-anchor" href="#Data-Masking-Operations">Data Masking Operations</a><a id="Data-Masking-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Masking-Operations" title="Permalink"></a></h2><h3 id="Overview-5"><a class="docs-heading-anchor" href="#Overview-5">Overview</a><a class="docs-heading-anchor-permalink" href="#Overview-5" title="Permalink"></a></h3><p><strong>Masking</strong> provides a powerful alternative to filtering that enables selective analysis without modifying the original dataset. Unlike filtering (which creates new tables), masking uses boolean arrays to mark which data points to include in calculations.</p><h3 id="Masking-vs-Filtering:-Key-Differences"><a class="docs-heading-anchor" href="#Masking-vs-Filtering:-Key-Differences">Masking vs Filtering: Key Differences</a><a id="Masking-vs-Filtering:-Key-Differences-1"></a><a class="docs-heading-anchor-permalink" href="#Masking-vs-Filtering:-Key-Differences" title="Permalink"></a></h3><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">Masking</th><th style="text-align: right">Filtering</th></tr><tr><td style="text-align: right"><strong>Data modification</strong></td><td style="text-align: right">Original table unchanged</td><td style="text-align: right">Creates new table</td></tr><tr><td style="text-align: right"><strong>Memory usage</strong></td><td style="text-align: right">Minimal (boolean array only)</td><td style="text-align: right">Higher (duplicate data)</td></tr><tr><td style="text-align: right"><strong>Reversibility</strong></td><td style="text-align: right">Easily reversible</td><td style="text-align: right">Requires re-filtering</td></tr><tr><td style="text-align: right"><strong>Function support</strong></td><td style="text-align: right">MERA functions with <code>mask=</code> parameter</td><td style="text-align: right">Standard table operations</td></tr><tr><td style="text-align: right"><strong>Use case</strong></td><td style="text-align: right">Statistical analysis, comparisons</td><td style="text-align: right">Data preprocessing, subset analysis</td></tr></table><h3 id="Masking-Methodology-Overview"><a class="docs-heading-anchor" href="#Masking-Methodology-Overview">Masking Methodology Overview</a><a id="Masking-Methodology-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Masking-Methodology-Overview" title="Permalink"></a></h3><p>MERA supports three approaches for creating boolean masks:</p><h4 id="1.-**External-Function-Approach**"><a class="docs-heading-anchor" href="#1.-**External-Function-Approach**">1. <strong>External Function Approach</strong></a><a id="1.-**External-Function-Approach**-1"></a><a class="docs-heading-anchor-permalink" href="#1.-**External-Function-Approach**" title="Permalink"></a></h4><ul><li>Custom functions for complex conditions</li><li>Reusable logic for repeated analysis</li><li>Best for sophisticated geometric or physical criteria</li></ul><h4 id="2.-**Inline-Lambda-Functions**"><a class="docs-heading-anchor" href="#2.-**Inline-Lambda-Functions**">2. <strong>Inline Lambda Functions</strong></a><a id="2.-**Inline-Lambda-Functions**-1"></a><a class="docs-heading-anchor-permalink" href="#2.-**Inline-Lambda-Functions**" title="Permalink"></a></h4><ul><li>Concise expressions for simple conditions</li><li>Optimal performance for straightforward criteria</li><li>Readable code for common filtering patterns</li></ul><h4 id="3.-**Array-based-Operations**"><a class="docs-heading-anchor" href="#3.-**Array-based-Operations**">3. <strong>Array-based Operations</strong></a><a id="3.-**Array-based-Operations**-1"></a><a class="docs-heading-anchor-permalink" href="#3.-**Array-based-Operations**" title="Permalink"></a></h4><ul><li>Direct mathematical operations on extracted arrays</li><li>Highest performance for vectorized calculations</li><li>Ideal for mathematical transformations</li></ul><h3 id="Mask-Types-and-Performance"><a class="docs-heading-anchor" href="#Mask-Types-and-Performance">Mask Types and Performance</a><a id="Mask-Types-and-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Mask-Types-and-Performance" title="Permalink"></a></h3><ul><li><strong>Vector{Bool}</strong>: Standard Julia boolean array (mutable)</li><li><strong>BitArray{1}</strong>: Compressed boolean storage (memory efficient)</li><li><strong>Performance</strong>: Both types work identically with MERA functions</li><li><strong>Memory</strong>: BitArray uses ~8x less memory for large datasets</li></ul><pre><code class="language-julia hljs">function ftest(value)
    density = (4. / gas.scale.Msol_pc3)
    if value &lt; density
        return true
     else
        return false
    end
end

mask_v1 = map(row-&gt;ftest(row.rho), gas.data);

println( length(mask_v1) )
println( typeof(mask_v1) )</code></pre><pre><code class="nohighlight hljs">849332
Vector{Bool}
</code></pre><h4 id="Version-2:-Short-Syntax"><a class="docs-heading-anchor" href="#Version-2:-Short-Syntax">Version 2: Short Syntax</a><a id="Version-2:-Short-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Version-2:-Short-Syntax" title="Permalink"></a></h4><h5 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example 1</a><a id="Example-1-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h5><pre><code class="language-julia hljs">mask_v2 = map(row-&gt;row.rho &lt; 4. / gas.scale.Msol_pc3, gas.data);

println( length(mask_v2) )
println( typeof(mask_v2) )</code></pre><pre><code class="nohighlight hljs">849332
Vector{Bool}
</code></pre><h5 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example 2</a><a id="Example-2-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h5><pre><code class="language-julia hljs">mask_v2b = getvar(gas, :rho, :Msol_pc3) .&gt; 1. ;

println( length(mask_v2b) )
println( typeof(mask_v2b) )</code></pre><pre><code class="nohighlight hljs">849332
BitVector
</code></pre><h4 id="Version-3:-Longer-Syntax"><a class="docs-heading-anchor" href="#Version-3:-Longer-Syntax">Version 3: Longer Syntax</a><a id="Version-3:-Longer-Syntax-1"></a><a class="docs-heading-anchor-permalink" href="#Version-3:-Longer-Syntax" title="Permalink"></a></h4><pre><code class="language-julia hljs">rho_array = select(gas.data, :rho);
mask_v3 = rho_array .&lt; 1. / gas.scale.Msol_pc3;

println( length(mask_v3) )
println( typeof(mask_v3) )</code></pre><pre><code class="nohighlight hljs">849332
BitVector
</code></pre><h4 id="Combine-Multiple-Masks"><a class="docs-heading-anchor" href="#Combine-Multiple-Masks">Combine Multiple Masks</a><a id="Combine-Multiple-Masks-1"></a><a class="docs-heading-anchor-permalink" href="#Combine-Multiple-Masks" title="Permalink"></a></h4><pre><code class="language-julia hljs"># create individual masks for different density and temperature regions
mask_h = getvar(gas, :rho, :nH) .&lt; 10. # cm-3
mask_l = getvar(gas, :rho, :nH) .&gt; 1e-2  # cm-3

mask_T1 = getvar(gas, :Temperature, :K) .&lt; 1e4 # K
mask_T2 = getvar(gas, :Temperature, :K) .&gt; 1e3  # K

# combine several masks to one
mask_tot = mask_h .* mask_l .* mask_T1 .* mask_T2

println( length(mask_tot) )
println( typeof(mask_tot) )</code></pre><pre><code class="nohighlight hljs">849332
BitVector
</code></pre><h3 id="Some-Functions-With-Masking-Functionality"><a class="docs-heading-anchor" href="#Some-Functions-With-Masking-Functionality">Some Functions With Masking Functionality</a><a id="Some-Functions-With-Masking-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Some-Functions-With-Masking-Functionality" title="Permalink"></a></h3><p>The masked rows are not considered in the calculations (mask-element = false ).</p><h3 id="MERA-Functions-with-Masking-Support"><a class="docs-heading-anchor" href="#MERA-Functions-with-Masking-Support">MERA Functions with Masking Support</a><a id="MERA-Functions-with-Masking-Support-1"></a><a class="docs-heading-anchor-permalink" href="#MERA-Functions-with-Masking-Support" title="Permalink"></a></h3><h4 id="Comprehensive-Function-Coverage"><a class="docs-heading-anchor" href="#Comprehensive-Function-Coverage">Comprehensive Function Coverage</a><a id="Comprehensive-Function-Coverage-1"></a><a class="docs-heading-anchor-permalink" href="#Comprehensive-Function-Coverage" title="Permalink"></a></h4><p>MERA&#39;s masking system integrates seamlessly with statistical and analysis functions:</p><p><strong>Mass and Density Analysis</strong>:</p><ul><li><p><code>msum()</code>: Total mass calculations with selective inclusion</p></li><li><p><code>mass_weighted_mean()</code>: Density-weighted averages</p></li><li><p><code>volume_weighted_mean()</code>: Volume-weighted statistics</p></li><li><p><code>center_of_mass()</code>: COM calculations for selected regions</p></li><li><p><code>bulk_velocity()</code>: Mean velocity vectors</p></li><li><p><code>velocity_dispersion()</code>: Turbulent velocity measurements</p></li><li><p><code>angular_momentum()</code>: Rotational properties</p></li><li><p><code>projection()</code>: projection of properties</p></li><li><p><code>getvar()</code></p></li></ul><h4 id="Masking-Implementation-Details"><a class="docs-heading-anchor" href="#Masking-Implementation-Details">Masking Implementation Details</a><a id="Masking-Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Masking-Implementation-Details" title="Permalink"></a></h4><p><strong>Mask Application</strong>: When <code>mask=mask_array</code> is provided:</p><ol><li><strong>Element verification</strong>: Mask length must match data table rows</li><li><strong>Automatic filtering</strong>: Only <code>true</code> elements included in calculations</li><li><strong>Weight preservation</strong>: Existing weighting schemes still apply</li><li><strong>Unit consistency</strong>: Results maintain proper physical units</li></ol><p><strong>Performance Optimization</strong>: Masked functions avoid data copying:</p><ul><li>Original table remains unchanged in memory</li><li>Boolean indexing provides efficient element selection</li><li>Computational cost scales with number of <code>true</code> elements, not total data size</li></ul><h3 id="Total-Mass"><a class="docs-heading-anchor" href="#Total-Mass">Total Mass</a><a id="Total-Mass-1"></a><a class="docs-heading-anchor-permalink" href="#Total-Mass" title="Permalink"></a></h3><pre><code class="language-julia hljs">mask = map(row-&gt;row.rho &lt; 1. / gas.scale.Msol_pc3, gas.data);
mtot_masked = msum(gas, :Msol, mask=mask)
mtot        = msum(gas, :Msol)
println()
println( &quot;Gas Mtot masked: &quot;, mtot_masked  , &quot; Msol&quot; )
println( &quot;Gas Mtot:        &quot;, mtot         , &quot; Msol&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Gas Mtot masked: 1.3369189531333082e10 Msol
Gas Mtot:        3.0968754148332745e10 Msol
</code></pre><pre><code class="language-julia hljs">mask = map(row-&gt;row.birth &lt; 100. / particles.scale.Myr, particles.data);
mtot_masked = msum(particles, :Msol, mask=mask)
mtot        = msum(particles, :Msol)
println()
println( &quot;Particles Mtot masked: &quot;, mtot_masked , &quot; Msol&quot; )
println( &quot;Particles Mtot:        &quot;, mtot        , &quot; Msol&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Particles Mtot masked: 1.4537556611888438e7 Msol
Particles Mtot:        5.804426008528429e9 Msol
</code></pre><pre><code class="language-julia hljs">mask = map(row-&gt;row.mass_cl &lt; 1e6 / clumps.scale.Msol, clumps.data);
mtot_masked = msum(clumps, :Msol, mask=mask)
mtot        = msum(clumps, :Msol)
println()
println( &quot;Clumps Mtot masked:    &quot;, mtot_masked , &quot; Msol&quot; )
println( &quot;Clumps Mtot:           &quot;, mtot        , &quot; Msol&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Clumps Mtot masked:    2.926390055686605e7 Msol
Clumps Mtot:           1.3743280681841675e10 Msol
</code></pre><h3 id="Mask-Creation-Method-Analysis"><a class="docs-heading-anchor" href="#Mask-Creation-Method-Analysis">Mask Creation Method Analysis</a><a id="Mask-Creation-Method-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Mask-Creation-Method-Analysis" title="Permalink"></a></h3><p><strong>Method Comparison for Same Condition</strong> (ρ &lt; 4 Msol/pc³):</p><table><tr><th style="text-align: right">Method</th><th style="text-align: right">Syntax</th><th style="text-align: right">Performance</th><th style="text-align: right">Memory Type</th><th style="text-align: right">Use Case</th></tr><tr><td style="text-align: right">External Function</td><td style="text-align: right"><code>map(row-&gt;ftest(row.rho), data)</code></td><td style="text-align: right">Slower</td><td style="text-align: right">Vector{Bool}</td><td style="text-align: right">Complex logic, reusability</td></tr><tr><td style="text-align: right">Lambda Expression</td><td style="text-align: right"><code>map(row-&gt;row.rho &lt; threshold, data)</code></td><td style="text-align: right">Fast</td><td style="text-align: right">Vector{Bool}</td><td style="text-align: right">Simple conditions</td></tr><tr><td style="text-align: right">Array Operations</td><td style="text-align: right"><code>getvar(...) .&lt; threshold</code></td><td style="text-align: right">Fastest</td><td style="text-align: right">BitArray{1}</td><td style="text-align: right">Vectorized operations</td></tr></table><p><strong>When to Use Each</strong>:</p><ul><li><strong>External functions</strong>: Complex geometric conditions, reusable logic blocks</li><li><strong>Lambda expressions</strong>: Simple comparisons, table-based operations</li><li><strong>Array operations</strong>: Mathematical transformations, vectorized calculations</li></ul><p>All three methods produce identical boolean results, differing only in implementation style and performance characteristics.</p><h3 id="Combining-Multiple-Masks"><a class="docs-heading-anchor" href="#Combining-Multiple-Masks">Combining Multiple Masks</a><a id="Combining-Multiple-Masks-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-Multiple-Masks" title="Permalink"></a></h3><h4 id="Boolean-Logic-Operations"><a class="docs-heading-anchor" href="#Boolean-Logic-Operations">Boolean Logic Operations</a><a id="Boolean-Logic-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Boolean-Logic-Operations" title="Permalink"></a></h4><p><strong>Mask Combination Operators</strong>:</p><ul><li><strong>Element-wise AND</strong> (<code>.&amp;</code> or <code>.*</code>): Both conditions must be true</li><li><strong>Element-wise OR</strong> (<code>.│</code>): Either condition can be true</li><li><strong>Element-wise NOT</strong> (<code>.!</code>): Inverts boolean values</li><li><strong>Multiplication</strong> (<code>.*</code>): Alternative AND syntax (0×anything = 0, 1×1 = 1)</li></ul><h4 id="Multi-Physics-Condition-Example"><a class="docs-heading-anchor" href="#Multi-Physics-Condition-Example">Multi-Physics Condition Example</a><a id="Multi-Physics-Condition-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Physics-Condition-Example" title="Permalink"></a></h4><p>This example creates a <strong>complex thermodynamic selection</strong>:</p><pre><code class="language-julia hljs"># Define individual conditions
mask_h = getvar(gas, :rho, :nH) .&lt; 10.0    # Low density: &lt; 10 cm⁻³
mask_l = getvar(gas, :rho, :nH) .&gt; 1e-2    # Higher density: &gt; 0.01 cm⁻³
mask_T1 = getvar(gas, :Temperature, :K) .&lt; 1e4 # Cool gas: &lt; 10⁴ K
mask_T2 = getvar(gas, :Temperature, :K) .&gt; 1e3  # Warm gas: &gt; 10³ K

# Combine all conditions
mask_tot = mask_h .* mask_l .* mask_T1 .* mask_T2</code></pre><p><strong>Efficiency Note</strong>: Using <code>.*</code> (element-wise multiplication) is computationally equivalent to <code>.&amp;</code> but often more readable for multiple conditions.</p><pre><code class="language-julia hljs">mask = map(row-&gt;row.rho &lt; 100. / gas.scale.nH, gas.data);
com_gas_masked = center_of_mass(gas, :kpc, mask=mask)
com_gas        = center_of_mass(gas, :kpc)
println()
println( &quot;Gas COM masked: &quot;, com_gas_masked , &quot; kpc&quot; )
println( &quot;Gas COM:        &quot;, com_gas        , &quot; kpc&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Gas COM masked: (23.632781376611643, 24.01793518773094, 24.078280687627124) kpc
Gas COM:        (23.472214016322592, 23.939318698656532, 24.084836371167793) kpc
</code></pre><pre><code class="language-julia hljs">mask = map(row-&gt;row.birth &lt; 100. / particles.scale.Myr, particles.data);
com_particles_masked = center_of_mass(particles, :kpc, mask=mask)
com_particles        = center_of_mass(particles, :kpc)
println()
println( &quot;Particles COM masked: &quot;, com_particles_masked , &quot; kpc&quot; )
println( &quot;Particles COM:        &quot;, com_particles        , &quot; kpc&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Particles COM masked: (22.766374936557934, 24.817294529838456, 24.02006559565021) kpc
Particles COM:        (22.891354761211396, 24.17414728268034, 24.003205056545642) kpc
</code></pre><pre><code class="language-julia hljs"># calculate joint center-of-mass from gas and particles
mask1 = map(row-&gt;row.rho &lt; 100. / gas.scale.nH, gas.data); # mask for the hydro data
mask2 = map(row-&gt;row.birth &lt; 100.  / particles.scale.Myr, particles.data); # mask for the particle data

println( &quot;Joint COM (Gas + Particles) masked: &quot;, center_of_mass([gas,particles], :kpc, mask=ask1, mask2]) , &quot; kpc&quot; )
println( &quot;Joint COM (Gas + Particles):        &quot;, center_of_mass([gas,particles], :kpc) , &quot; kpc&quot; )</code></pre><pre><code class="nohighlight hljs">Joint COM (Gas + Particles) masked: (23.63201475313947, 24.018642485836217, 24.078229177093796) kpc
Joint COM (Gas + Particles):        (23.380528865091303, 23.97638498224044, 24.071951357132512) kpc
</code></pre><pre><code class="language-julia hljs">mask = map(row-&gt;row.mass_cl &lt; 1e6 / clumps.scale.Msol, clumps.data);
com_clumps_masked = center_of_mass(clumps, mask=mask)
com_clumps        = center_of_mass(clumps)
println()
println( &quot;Clumps COM masked:&quot;, com_clumps_masked .* clumps.scale.kpc, &quot; kpc&quot; )
println( &quot;Clumps COM:       &quot;, com_clumps        .* clumps.scale.kpc, &quot; kpc&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Clumps COM masked:(22.97967662229681, 23.224479869848984, 24.110568064737457) kpc
Clumps COM:       (23.135765457064572, 23.741712325649264, 24.0050127185862) kpc
</code></pre><h3 id="Bulk-Velocity"><a class="docs-heading-anchor" href="#Bulk-Velocity">Bulk-Velocity</a><a id="Bulk-Velocity-1"></a><a class="docs-heading-anchor-permalink" href="#Bulk-Velocity" title="Permalink"></a></h3><pre><code class="language-julia hljs">mask = map(row-&gt;row.rho &lt; 100. / gas.scale.nH, gas.data);
bv_gas_masked = bulk_velocity(gas, :km_s, mask=mask)
bv_gas        = bulk_velocity(gas, :km_s)
println()
println( &quot;Gas bulk velocity masked: &quot;, bv_gas_masked , &quot; km/s&quot; )
println( &quot;Gas bulk velocity:        &quot;, bv_gas        , &quot; km/s&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Gas bulk velocity masked: (-0.04633670340113768, -6.609934798406887, -1.000280146674773) km/s
Gas bulk velocity:        (-1.1999253584798222, -10.678485153330127, -0.44038538452508885) km/s
</code></pre><pre><code class="language-julia hljs">mask = map(row-&gt;row.birth &lt; 100. / particles.scale.Myr, particles.data);
bv_particles_masked = bulk_velocity(particles, :km_s, mask=mask)
bv_particles        = bulk_velocity(particles, :km_s)
println()
println( &quot;Particles bulk velocity masked: &quot;, bv_particles_masked , &quot; km/s&quot; )
println( &quot;Particles bulk velocity:        &quot;, bv_particles        , &quot; km/s&quot; )
println()</code></pre><pre><code class="nohighlight hljs">
Particles bulk velocity masked: (-27.70225411383651, -7.532075727552787, -1.3273993940211153) km/s
Particles bulk velocity:        (-11.623422700314567, -18.440572802490294, -0.32919277314175355) km/s
</code></pre><h3 id="Weighted-Statistics"><a class="docs-heading-anchor" href="#Weighted-Statistics">Weighted Statistics</a><a id="Weighted-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Weighted-Statistics" title="Permalink"></a></h3><p>(It is also possible to use the mask within the <code>getvar</code> function)</p><pre><code class="language-julia hljs">maskgas   = map(row-&gt;row.rho &lt; 100. / gas.scale.nH, gas.data);
maskpart  = map(row-&gt;row.birth &lt; 100.  / particles.scale.Myr, particles.data);
maskclump = map(row-&gt;row.mass_cl &lt; 1e7 / clumps.scale.Msol, clumps.data);

stats_gas_masked       = wstat( getvar(gas,       :vx,     :km_s), weight=getvar(gas,       :mass  ),  mask=maskgas);
stats_particles_masked = wstat( getvar(particles, :vx,     :km_s), weight=getvar(particles, :mass   ), mask=maskpart);
stats_clumps_masked    = wstat( getvar(clumps,    :peak_x, :kpc ), weight=getvar(clumps,    :mass_cl), mask=maskclump)  ;

println( &quot;Gas        &lt;vx&gt;_cells masked      : &quot;,  stats_gas_masked.mean,       &quot; km/s (mass weighted)&quot; )
println( &quot;Particles  &lt;vx&gt;_particles masked  : &quot;,  stats_particles_masked.mean, &quot; km/s (mass weighted)&quot; )
println( &quot;Clumps &lt;peak_x&gt;_clumps masked     : &quot;,  stats_clumps_masked.mean,    &quot; kpc  (mass weighted)&quot; )
println()</code></pre><pre><code class="nohighlight hljs">Gas        &lt;vx&gt;_cells masked      : -0.046336703401136776 km/s (mass weighted)
Particles  &lt;vx&gt;_particles masked  : -27.70225411383651 km/s (mass weighted)
Clumps &lt;peak_x&gt;_clumps masked     : 22.907689025275953 kpc  (mass weighted)
</code></pre><pre><code class="language-julia hljs">stats_gas       = wstat( getvar(gas,       :vx,     :km_s), weight=getvar(gas,       :mass  ));
stats_particles = wstat( getvar(particles, :vx,     :km_s), weight=getvar(particles, :mass   ));
stats_clumps    = wstat( getvar(clumps,    :peak_x, :kpc ), weight=getvar(clumps,    :mass_cl))  ;

println( &quot;Gas        &lt;vx&gt;_allcells     : &quot;,  stats_gas.mean,       &quot; km/s (mass weighted)&quot; )
println( &quot;Particles  &lt;vx&gt;_allparticles : &quot;,  stats_particles.mean, &quot; km/s (mass weighted)&quot; )
println( &quot;Clumps &lt;peak_x&gt;_allclumps    : &quot;,  stats_clumps.mean,    &quot; kpc  (mass weighted)&quot; )
println()</code></pre><pre><code class="nohighlight hljs">Gas        &lt;vx&gt;_allcells     : -1.1999253584798235 km/s (mass weighted)
Particles  &lt;vx&gt;_allparticles : -11.623422700314565 km/s (mass weighted)
Clumps &lt;peak_x&gt;_allclumps    : 23.135765457064576 kpc  (mass weighted)
</code></pre><h2 id="Tutorial-Summary"><a class="docs-heading-anchor" href="#Tutorial-Summary">Tutorial Summary</a><a id="Tutorial-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-Summary" title="Permalink"></a></h2><h3 id="Key-Concepts-Mastered"><a class="docs-heading-anchor" href="#Key-Concepts-Mastered">Key Concepts Mastered</a><a id="Key-Concepts-Mastered-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts-Mastered" title="Permalink"></a></h3><p>This tutorial has covered the essential data manipulation techniques in MERA.jl:</p><h4 id="Data-Selection-Mastery"><a class="docs-heading-anchor" href="#Data-Selection-Mastery">Data Selection Mastery</a><a id="Data-Selection-Mastery-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Selection-Mastery" title="Permalink"></a></h4><ul><li><strong>IndexedTables methods</strong>: <code>select()</code>, <code>columns()</code> for high-performance data extraction</li><li><strong>MERA functions</strong>: <code>getvar()</code> with automatic unit conversion and derived quantities</li><li><strong>Performance trade-offs</strong>: Speed vs functionality considerations for different use cases</li></ul><h4 id="Advanced-Filtering-Techniques"><a class="docs-heading-anchor" href="#Advanced-Filtering-Techniques">Advanced Filtering Techniques</a><a id="Advanced-Filtering-Techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Filtering-Techniques" title="Permalink"></a></h4><ul><li><strong>Single conditions</strong>: Basic boolean filtering with proper unit conversion</li><li><strong>Multi-criteria selection</strong>: Complex geometric and physical constraints</li><li><strong>Pipeline macros</strong>: <code>@filter</code>, <code>@apply</code>, <code>@where</code> for elegant workflow design</li><li><strong>Performance optimization</strong>: Sequential vs combined filtering strategies</li></ul><h4 id="Masking-Operations"><a class="docs-heading-anchor" href="#Masking-Operations">Masking Operations</a><a id="Masking-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Masking-Operations" title="Permalink"></a></h4><ul><li><strong>Boolean array creation</strong>: Three distinct approaches with performance characteristics</li><li><strong>Mask combination</strong>: Logical operations for complex multi-physics conditions</li><li><strong>Function integration</strong>: Seamless masking support across MERA&#39;s analysis suite</li><li><strong>Memory efficiency</strong>: Non-destructive analysis preserving original datasets</li></ul><h4 id="Data-Extension-and-Modification"><a class="docs-heading-anchor" href="#Data-Extension-and-Modification">Data Extension and Modification</a><a id="Data-Extension-and-Modification-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Extension-and-Modification" title="Permalink"></a></h4><ul><li><strong>Table transformation</strong>: Adding computed variables with <code>transform()</code> and <code>insertcolsafter()</code></li><li><strong>Derived quantities</strong>: Integration of custom calculations into MERA workflows</li><li><strong>Unit management</strong>: Proper handling of code units vs physical quantities</li></ul><h3 id="Key-Takeaway"><a class="docs-heading-anchor" href="#Key-Takeaway">Key Takeaway</a><a id="Key-Takeaway-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Takeaway" title="Permalink"></a></h3><p><strong>Mastering data selection, filtering, and masking is fundamental to effective astrophysical data analysis.</strong> These techniques enable you to focus computational resources on physically relevant subsets while maintaining flexibility to explore different selection criteria without data duplication.</p><p>The combination of IndexedTables&#39; performance with MERA&#39;s domain-specific functionality provides a powerful toolkit for sophisticated astrophysical data analysis workflows.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/calculations/">« API Reference</a><a class="docs-footer-nextpage" href="../api/masking_filtering/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 18 August 2025 19:36">Monday 18 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
