<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>11 Multi-Threading · Mera.jl</title><meta name="title" content="11 Multi-Threading · Mera.jl"/><meta property="og:title" content="11 Multi-Threading · Mera.jl"/><meta property="twitter:title" content="11 Multi-Threading · Mera.jl"/><meta name="description" content="Documentation for Mera.jl."/><meta property="og:description" content="Documentation for Mera.jl."/><meta property="twitter:description" content="Documentation for Mera.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Mera.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../00_multi_FirstSteps/">First Steps</a></li><li><span class="tocitem">1 Data Inspection</span><ul><li><a class="tocitem" href="../../01_hydro_First_Inspection/">Hydro</a></li><li><a class="tocitem" href="../../01_particles_First_Inspection/">Particles</a></li><li><a class="tocitem" href="../../01_clumps_First_Inspection/">Clumps</a></li></ul></li><li><span class="tocitem">2 Load by Selection</span><ul><li><a class="tocitem" href="../../02_hydro_Load_Selections/">Hydro</a></li><li><a class="tocitem" href="../../02_particles_Load_Selections/">Particles</a></li><li><a class="tocitem" href="../../02_clumps_Load_Selections/">Clumps</a></li></ul></li><li><span class="tocitem">3 Get Subregions</span><ul><li><a class="tocitem" href="../../03_hydro_Get_Subregions/03_hydro_Get_Subregions/">Hydro</a></li><li><a class="tocitem" href="../../03_particles_Get_Subregions/03_particles_Get_Subregions/">Particles</a></li><li><a class="tocitem" href="../../03_clumps_Get_Subregions/03_clumps_Get_Subregions/">Clumps</a></li></ul></li><li><a class="tocitem" href="../../04_multi_Basic_Calculations/">4 Basic Calculations</a></li><li><a class="tocitem" href="../../05_multi_Masking_Filtering/05_multi_Masking_Filtering/">5 Mask/Filter/Meta</a></li><li><span class="tocitem">6 Projection</span><ul><li><a class="tocitem" href="../../06_hydro_Projection/06_hydro_Projection/">Hydro</a></li><li><a class="tocitem" href="../../06_particles_Projection/06_particles_Projection/">Particles</a></li></ul></li><li><span class="tocitem">7 MERA-Files</span><ul><li><a class="tocitem" href="../../07_multi_Mera_Files/">Mera-Files</a></li><li><a class="tocitem" href="../../07_1_multi_Mera_Files_Converter/">Converter</a></li></ul></li><li><span class="tocitem">8 Volume Rendering</span><ul><li><a class="tocitem" href="../../paraview_intro/">Intro</a></li><li><a class="tocitem" href="../../08_hydro_VTK_export/">Hydro</a></li><li><a class="tocitem" href="../../08_particles_VTK_export/">Particles</a></li></ul></li><li><a class="tocitem" href="../../Miscellaneous/">9 Miscellaneous</a></li><li><a class="tocitem" href="../../examples/">10 Examples</a></li><li class="is-active"><a class="tocitem" href>11 Multi-Threading</a><ul class="internal"><li><a class="tocitem" href="#Table-of-Contents"><span>Table of Contents</span></a></li><li><a class="tocitem" href="#1-Introduction-to-Multi-Threading-and-GC"><span>1 Introduction to Multi-Threading &amp; GC</span></a></li><li><a class="tocitem" href="#2-Memory-Management-and-Garbage-Collection"><span>2 Memory Management &amp; Garbage Collection</span></a></li><li><a class="tocitem" href="#3-Understanding-Oversubscription-and-max_threads"><span>3 Understanding Oversubscription &amp; <code>max_threads</code></span></a></li><li><a class="tocitem" href="#4-Setting-Up-Julia-for-Threading"><span>4 Setting Up Julia for Threading</span></a></li><li><a class="tocitem" href="#5-MERA&#39;s-Internally-Threaded-Functions"><span>5 MERA&#39;s Internally Threaded Functions</span></a></li><li><a class="tocitem" href="#6-Core-Threading-Patterns"><span>6 Core Threading Patterns</span></a></li><li><a class="tocitem" href="#7-Advanced-Threading-Patterns"><span>7 Advanced Threading Patterns</span></a></li><li><a class="tocitem" href="#8-Thread-Safe-Programming"><span>8 Thread-Safe Programming</span></a></li><li><a class="tocitem" href="#9-Transforming-Single-Threaded-Tutorials"><span>9 Transforming Single-Threaded Tutorials</span></a></li><li><a class="tocitem" href="#10-Benchmarking-and-Performance-Tuning"><span>10 Benchmarking &amp; Performance Tuning</span></a></li><li><a class="tocitem" href="#11-Best-Practices-and-Troubleshooting"><span>11 Best Practices &amp; Troubleshooting</span></a></li><li><a class="tocitem" href="#12-Complete-Working-Examples"><span>12 Complete Working Examples</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><span class="tocitem">12 Benchmarks</span><ul><li><a class="tocitem" href="../../benchmarks/IO/IOperformance/">Server IO</a></li><li><a class="tocitem" href="../../benchmarks/RAMSES_reading/ramses_reading/">Parallel RAMSES-Files Reading</a></li><li><a class="tocitem" href="../../benchmarks/JLD2_reading/Mera_files_reading/">Mera-Files Reading</a></li><li><a class="tocitem" href="../../benchmarks/Projection/multi_projections/">Parallel Projections</a></li></ul></li><li><span class="tocitem">13 Reference Guide</span><ul><li><a class="tocitem" href="../../quickreference/Julia_Quick_Reference/">Julia</a></li><li><a class="tocitem" href="../../quickreference/Mera_Quick_Reference/">Mera</a></li></ul></li><li><a class="tocitem" href="../../api/">14 API Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>11 Multi-Threading</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>11 Multi-Threading</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ManuelBehrendt/Mera.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ManuelBehrendt/Mera.jl/blob/master/docs/src/multi-threading/multi-threading_intro.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Multi-Threading-and-Garbage-Collection-in-MERA"><a class="docs-heading-anchor" href="#Multi-Threading-and-Garbage-Collection-in-MERA">Multi-Threading &amp; Garbage Collection in MERA</a><a id="Multi-Threading-and-Garbage-Collection-in-MERA-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Threading-and-Garbage-Collection-in-MERA" title="Permalink"></a></h1><p><em>Complete guide for high-performance RAMSES simulation analysis with Julia 1.10+</em></p><p><strong>Main Takeaways</strong>  </p><ul><li>Julia&#39;s <strong>composable threading</strong> and <strong>parallel GC</strong> for multi-GB AMR loads, projections, and VTK exports </li><li><strong>Oversubscription</strong> creates performance bottlenecks—use MERA&#39;s <code>max_threads</code> keyword to prevent this when combining threading levels  </li><li><strong>Benchmark</strong> each threaded function to find your server&#39;s optimal thread counts  </li><li>Examples to transform your existing code into parallel workflows with minimal changes</li></ul><h2 id="Table-of-Contents"><a class="docs-heading-anchor" href="#Table-of-Contents">Table of Contents</a><a id="Table-of-Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-Contents" title="Permalink"></a></h2><ol><li><a href="#1-introduction">Introduction to Multi-Threading &amp; GC</a></li><li><a href="#2-memory-management--garbage-collection">Memory Management &amp; Garbage Collection</a>  </li><li><a href="#3-understanding-oversubscription--max_threads">Understanding Oversubscription &amp; max_threads</a></li><li><a href="#4-setting-up-julia-for-threading">Setting Up Julia for Threading</a></li><li><a href="#5-MERAll-internally-threaded-functions">MERA&#39;s Internally Threaded Functions</a></li><li><a href="#6-core-threading-patterns">Core Threading Patterns</a></li><li><a href="#7-advanced-threading-patterns">Advanced Threading Patterns</a></li><li><a href="#8-thread-safe-programming">Thread-Safe Programming</a></li><li><a href="#9-transforming-single-threaded-tutorials">Transforming Single-Threaded Tutorials</a></li><li><a href="#10-benchmarking--performance-tuning">Benchmarking &amp; Performance Tuning</a></li><li><a href="#11-best-practices--troubleshooting">Best Practices &amp; Troubleshooting</a></li><li><a href="#12-complete-working-examples">Complete Working Examples</a></li></ol><h2 id="1-Introduction-to-Multi-Threading-and-GC"><a class="docs-heading-anchor" href="#1-Introduction-to-Multi-Threading-and-GC">1 Introduction to Multi-Threading &amp; GC</a><a id="1-Introduction-to-Multi-Threading-and-GC-1"></a><a class="docs-heading-anchor-permalink" href="#1-Introduction-to-Multi-Threading-and-GC" title="Permalink"></a></h2><h3 id="1.1-Why-Multi-Threading-Matters-for-Scientists"><a class="docs-heading-anchor" href="#1.1-Why-Multi-Threading-Matters-for-Scientists">1.1 Why Multi-Threading Matters for Scientists</a><a id="1.1-Why-Multi-Threading-Matters-for-Scientists-1"></a><a class="docs-heading-anchor-permalink" href="#1.1-Why-Multi-Threading-Matters-for-Scientists" title="Permalink"></a></h3><p>Julia&#39;s <strong>native multi-threading</strong> lets you utilize your available cores within pure Julia code—no external libraries, MPI, or complex setup required.</p><p><strong>For MERA users</strong>, this means the following functions are already internally parallized:</p><ul><li><strong>AMR data loading</strong> (<code>gethydro</code>/<code>getgravity</code>) reads levels concurrently  </li><li><strong>Particle streaming</strong> (<code>getparticles</code>) processes files in parallel  </li><li><strong>Projection creation</strong> (<code>projection</code>) spawns one thread per variable for hydro data</li><li><strong>VTK export</strong> (<code>export_vtk</code>) writes chunks simultaneously  </li></ul><h3 id="1.2-Julia&#39;s-Unique-Advantage:-Composable-Threading"><a class="docs-heading-anchor" href="#1.2-Julia&#39;s-Unique-Advantage:-Composable-Threading">1.2 Julia&#39;s Unique Advantage: Composable Threading</a><a id="1.2-Julia&#39;s-Unique-Advantage:-Composable-Threading-1"></a><a class="docs-heading-anchor-permalink" href="#1.2-Julia&#39;s-Unique-Advantage:-Composable-Threading" title="Permalink"></a></h3><p>Unlike languages that retrofit parallelism, Julia was designed with <strong>composable threading</strong> from the ground up. When one multi-threaded function calls another multi-threaded function, Julia&#39;s scheduler coordinates all threads globally without oversubscribing resources.</p><p>This architectural advantage is crucial for scientific computing where you might:</p><ul><li>Process multiple simulation snapshots simultaneously</li><li>Run different analysis algorithms in parallel  </li><li>Export visualization data while computing results</li><li>Perform parameter sweeps with thousands of iterations</li></ul><h3 id="1.3-Parallel-Garbage-Collection"><a class="docs-heading-anchor" href="#1.3-Parallel-Garbage-Collection">1.3 Parallel Garbage Collection</a><a id="1.3-Parallel-Garbage-Collection-1"></a><a class="docs-heading-anchor-permalink" href="#1.3-Parallel-Garbage-Collection" title="Permalink"></a></h3><p>Julia 1.10+ introduces <strong>parallel garbage collection</strong>—the GC&#39;s mark phase runs on multiple threads, dramatically reducing pause times for allocation-heavy applications. This is especially important when processing large RAMSES datasets that create many temporary objects.</p><h2 id="2-Memory-Management-and-Garbage-Collection"><a class="docs-heading-anchor" href="#2-Memory-Management-and-Garbage-Collection">2 Memory Management &amp; Garbage Collection</a><a id="2-Memory-Management-and-Garbage-Collection-1"></a><a class="docs-heading-anchor-permalink" href="#2-Memory-Management-and-Garbage-Collection" title="Permalink"></a></h2><h3 id="2.1-Stack-vs-Heap-Memory"><a class="docs-heading-anchor" href="#2.1-Stack-vs-Heap-Memory">2.1 Stack vs Heap Memory</a><a id="2.1-Stack-vs-Heap-Memory-1"></a><a class="docs-heading-anchor-permalink" href="#2.1-Stack-vs-Heap-Memory" title="Permalink"></a></h3><p>Understanding Julia&#39;s memory model helps optimize threaded code:</p><p><strong>Stack Memory</strong></p><ul><li>Fast, linear LIFO (Last-In-First-Out) structure</li><li>Stores local variables, function parameters, return addresses</li><li>Fixed size, known at compile time</li><li>Automatically freed when function returns</li></ul><p><strong>Heap Memory</strong>  </p><ul><li>Flexible region for dynamic objects</li><li>Arrays, dictionaries, complex data structures</li><li>Size determined at runtime</li><li>Managed by garbage collector</li></ul><pre><code class="language-julia hljs">function memory_example()
    x = 5.0                    # Stack: small, fixed-size local
    arr = rand(10^6)           # Heap: large, dynamic array
    return sum(arr)            # Stack freed automatically, arr marked for GC
end</code></pre><h3 id="2.2-Julia&#39;s-Garbage-Collector-Explained"><a class="docs-heading-anchor" href="#2.2-Julia&#39;s-Garbage-Collector-Explained">2.2 Julia&#39;s Garbage Collector Explained</a><a id="2.2-Julia&#39;s-Garbage-Collector-Explained-1"></a><a class="docs-heading-anchor-permalink" href="#2.2-Julia&#39;s-Garbage-Collector-Explained" title="Permalink"></a></h3><p>Julia implements a <strong>generational, mark-and-sweep collector</strong>:</p><p><strong>Mark Phase</strong>: Starting from &quot;roots&quot; (global variables, local variables on call stacks), the GC traces all reachable objects. Julia 1.10+ parallelizes this phase across multiple threads.</p><p><strong>Sweep Phase</strong>: Unreachable objects are deallocated and memory returned to the system.</p><p><strong>Generational Strategy</strong>: Most objects die young. The GC focuses on recently allocated objects, which are statistically more likely to be garbage.</p><h3 id="2.3-Monitoring-GC-Performance"><a class="docs-heading-anchor" href="#2.3-Monitoring-GC-Performance">2.3 Monitoring GC Performance</a><a id="2.3-Monitoring-GC-Performance-1"></a><a class="docs-heading-anchor-permalink" href="#2.3-Monitoring-GC-Performance" title="Permalink"></a></h3><p>Use <code>@time</code> to monitor GC impact:</p><pre><code class="language-julia hljs">@time result = analyze_large_dataset(data)
# Output: 2.345 seconds (1.23 M allocations: 456.7 MiB, 15.2% gc time)</code></pre><p>The <strong>15.2% gc time</strong> indicates that over 15% of execution time was spent in garbage collection. Values above 10-20% suggest optimization opportunities.</p><h3 id="2.4-GC-Optimization-Strategies"><a class="docs-heading-anchor" href="#2.4-GC-Optimization-Strategies">2.4 GC Optimization Strategies</a><a id="2.4-GC-Optimization-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#2.4-GC-Optimization-Strategies" title="Permalink"></a></h3><p><strong>Minimize Allocations</strong></p><pre><code class="language-julia hljs"># BAD: Creates temporary arrays
function inefficient_physics(positions, velocities, masses)
    kinetic = 0.5 .* masses .* (velocities .^ 2)  # Temporary array
    potential = compute_potential(positions)       # Another temporary
    return sum(kinetic) + sum(potential)          # More temporaries
end

# GOOD: Single pass, no allocations  
# No intermediate arrays: every arithmetic operation writes straight into the scalar total
function efficient_physics(positions, velocities, masses)
    total_energy = 0.0
    for i in eachindex(positions)
        total_energy += 0.5 * masses[i] * velocities[i]^2
        total_energy += compute_potential_at(positions[i])
    end
    return total_energy
end</code></pre><h4 id="Allocation-Free-Variants-That-Keep-Broadcasting-Style"><a class="docs-heading-anchor" href="#Allocation-Free-Variants-That-Keep-Broadcasting-Style">-&gt; Allocation-Free Variants That Keep Broadcasting Style</a><a id="Allocation-Free-Variants-That-Keep-Broadcasting-Style-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-Free-Variants-That-Keep-Broadcasting-Style" title="Permalink"></a></h4><pre><code class="language-Julia hljs"># 1. Fuse Everything and Stream to a Pre-Allocated Vector
# The dotted assignment out .= … fuses all elementwise operations and writes directly into out, so no extra storage is needed
function energy_broadcast!(out, pos, vel, m)
    @. out = 0.5*m*vel^2 + compute_potential_at(pos)
    return sum(out)
end</code></pre><pre><code class="language-Julia hljs"># 2. Map-Reduce Without Intermediates
energy_mapreduce(pos, vel, m) = mapreduce(i -&gt; 0.5*m[i]*vel[i]^2 + compute_potential_at(pos[i]), +, eachindex(pos))</code></pre><p><strong>Preallocate Arrays</strong></p><pre><code class="language-julia hljs"># BAD: Growing arrays cause repeated reallocations
function collect_slow(n)
    results = Float64[]  # Starts empty
    for i in 1:n
        push!(results, expensive_calc(i))  # Repeated reallocations
    end
    return results
end

# GOOD: Allocate once
function collect_fast(n)
    results = Vector{Float64}(undef, n)  # Single allocation
    for i in 1:n
        results[i] = expensive_calc(i)
    end
    return results
end</code></pre><p><strong>Use In-Place Operations</strong></p><pre><code class="language-julia hljs"># BAD: Creates new arrays
function update_slow(state, forces, dt)
    new_vel = state.velocities + forces .* dt      # New array
    new_pos = state.positions + new_vel .* dt      # Another new array
    return SimulationState(new_pos, new_vel)
end

# GOOD: In-place updates
function update_fast!(state, forces, dt)
    @. state.velocities += forces * dt             # In-place
    @. state.positions += state.velocities * dt    # In-place  
    return state
end</code></pre><h2 id="3-Understanding-Oversubscription-and-max_threads"><a class="docs-heading-anchor" href="#3-Understanding-Oversubscription-and-max_threads">3 Understanding Oversubscription &amp; <code>max_threads</code></a><a id="3-Understanding-Oversubscription-and-max_threads-1"></a><a class="docs-heading-anchor-permalink" href="#3-Understanding-Oversubscription-and-max_threads" title="Permalink"></a></h2><h3 id="3.1-What-Is-Oversubscription?"><a class="docs-heading-anchor" href="#3.1-What-Is-Oversubscription?">3.1 What Is Oversubscription?</a><a id="3.1-What-Is-Oversubscription?-1"></a><a class="docs-heading-anchor-permalink" href="#3.1-What-Is-Oversubscription?" title="Permalink"></a></h3><p><strong>Oversubscription</strong> occurs when you have more runnable threads than physical CPU cores. The operating system must constantly switch between threads, leading to:</p><ul><li><strong>Context switch overhead</strong>: Saving and restoring thread state takes time</li><li><strong>Cache thrashing</strong>: Threads compete for the same CPU caches, reducing efficiency</li><li><strong>Memory bandwidth contention</strong>: Multiple threads saturate memory channels</li><li><strong>False sharing</strong>: Different threads modify variables on the same cache line</li></ul><h3 id="3.2-Why-Oversubscription-Happens-with-MERA"><a class="docs-heading-anchor" href="#3.2-Why-Oversubscription-Happens-with-MERA">3.2 Why Oversubscription Happens with MERA</a><a id="3.2-Why-Oversubscription-Happens-with-MERA-1"></a><a class="docs-heading-anchor-permalink" href="#3.2-Why-Oversubscription-Happens-with-MERA" title="Permalink"></a></h3><p>While Julia&#39;s composable threading usually prevents oversubscription, it can still occur in MERA workflows:</p><pre><code class="language-julia hljs"># PROBLEMATIC: Can create too many threads
@threads for snapshot in snapshots              # 8 outer threads
    gas = gethydro(info; lmax=10)               # 8 inner threads each
    projection(gas, [:rho, :T, :vx, :vy])      # 4 more threads per call
end
# Total: 8 × (8 + 4) = 96 threads on an 8-core machine!</code></pre><h3 id="3.3-The-max_threads-Solution"><a class="docs-heading-anchor" href="#3.3-The-max_threads-Solution">3.3 The <code>max_threads</code> Solution</a><a id="3.3-The-max_threads-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#3.3-The-max_threads-Solution" title="Permalink"></a></h3><p>MERA functions accept a <code>max_threads::Integer</code> keyword to cap internal threading:</p><pre><code class="language-julia hljs"># SOLUTION: Control thread allocation
@threads for snapshot in snapshots              # 8 outer threads
    gas = gethydro(info; lmax=10, max_threads=1)    # Serial loader
    projection(gas, [:rho, :T]; max_threads=2)      # 2 threads per projection
end
# Total: 8 outer + managed inner threads = controlled load</code></pre><p><strong><code>max_threads</code> Options:</strong></p><ul><li><code>max_threads = Threads.nthreads()</code> (default): Use all available threads</li><li><code>max_threads = 1</code>: Run completely serially  </li></ul><h2 id="4-Setting-Up-Julia-for-Threading"><a class="docs-heading-anchor" href="#4-Setting-Up-Julia-for-Threading">4 Setting Up Julia for Threading</a><a id="4-Setting-Up-Julia-for-Threading-1"></a><a class="docs-heading-anchor-permalink" href="#4-Setting-Up-Julia-for-Threading" title="Permalink"></a></h2><h3 id="4.1-Basic-Thread-Configuration"><a class="docs-heading-anchor" href="#4.1-Basic-Thread-Configuration">4.1 Basic Thread Configuration</a><a id="4.1-Basic-Thread-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#4.1-Basic-Thread-Configuration" title="Permalink"></a></h3><p>By default, Julia starts with a single thread:</p><pre><code class="language-julia hljs">julia&gt; Threads.nthreads()
1</code></pre><p>Enable multi-threading at startup:</p><pre><code class="language-bash hljs"># Command line argument (recommended)
julia --threads=8                    # 8 threads total
julia --threads=auto                 # Auto-detect optimal count  
julia -t 4                          # Short form

# Environment variable method
export JULIA_NUM_THREADS=8
julia</code></pre><h3 id="4.2-Advanced-Configuration-(Julia-1.10)"><a class="docs-heading-anchor" href="#4.2-Advanced-Configuration-(Julia-1.10)">4.2 Advanced Configuration (Julia 1.10+)</a><a id="4.2-Advanced-Configuration-(Julia-1.10)-1"></a><a class="docs-heading-anchor-permalink" href="#4.2-Advanced-Configuration-(Julia-1.10)" title="Permalink"></a></h3><p>Julia 1.10+ supports <strong>two thread pools</strong> and <strong>parallel GC</strong>:</p><pre><code class="language-bash hljs"># 8 compute threads, 2 interactive threads, 4 GC threads
julia --threads=8,2 --gcthreads=4

# Auto-configure everything (recommended for beginners)
julia --threads=auto --gcthreads=auto</code></pre><p><strong>Thread Pools:</strong></p><ul><li><strong><code>:default</code></strong> pool: Compute-intensive tasks</li><li><strong><code>:interactive</code></strong> pool: UI and responsive operations (keeps REPL responsive)</li></ul><p><strong>Verification:</strong></p><pre><code class="language-julia hljs">using Base.Threads

println(&quot;Compute threads: &quot;, nthreads(:default))
println(&quot;Interactive threads: &quot;, nthreads(:interactive))  
println(&quot;Current thread: &quot;, threadid())
println(&quot;Current pool: &quot;, threadpool())
# println(&quot;GC threads: &quot;, ngcthreads())  # before Julia 1.10+

# Optimize BLAS for linear algebra
using LinearAlgebra
BLAS.set_num_threads(min(4, nthreads()))
println(&quot;BLAS threads: &quot;, BLAS.get_num_threads())</code></pre><h3 id="4.3-Recommended-Configurations"><a class="docs-heading-anchor" href="#4.3-Recommended-Configurations">4.3 Recommended Configurations</a><a id="4.3-Recommended-Configurations-1"></a><a class="docs-heading-anchor-permalink" href="#4.3-Recommended-Configurations" title="Permalink"></a></h3><p><strong>For laptops/workstations (4-8 cores):</strong></p><pre><code class="language-bash hljs">julia --threads=auto --gcthreads=auto</code></pre><p><strong>For smaller servers (16+ cores):</strong></p><pre><code class="language-bash hljs">julia --threads=12,2 --gcthreads=6</code></pre><p><strong>For larger servers:</strong></p><pre><code class="language-bash hljs">julia --threads=32,4 --gcthreads=16</code></pre><h2 id="5-MERA&#39;s-Internally-Threaded-Functions"><a class="docs-heading-anchor" href="#5-MERA&#39;s-Internally-Threaded-Functions">5 MERA&#39;s Internally Threaded Functions</a><a id="5-MERA&#39;s-Internally-Threaded-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#5-MERA&#39;s-Internally-Threaded-Functions" title="Permalink"></a></h2><h3 id="5.1-Overview-of-Threaded-Functions"><a class="docs-heading-anchor" href="#5.1-Overview-of-Threaded-Functions">5.1 Overview of Threaded Functions</a><a id="5.1-Overview-of-Threaded-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#5.1-Overview-of-Threaded-Functions" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Threading Strategy</th><th style="text-align: right">Default Threads</th><th style="text-align: right"><code>max_threads</code></th></tr><tr><td style="text-align: right"><code>gethydro</code></td><td style="text-align: right">One task processes multiple files sequentially (load balancing)</td><td style="text-align: right"><code>Threads.nthreads()</code></td><td style="text-align: right">✓</td></tr><tr><td style="text-align: right">-&gt;</td><td style="text-align: right">For final table creation: parallel by column</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>getgravity</code></td><td style="text-align: right">Same strategy as <code>gethydro</code></td><td style="text-align: right"><code>Threads.nthreads()</code></td><td style="text-align: right">✓</td></tr><tr><td style="text-align: right"><code>getparticles</code></td><td style="text-align: right">Same strategy as <code>gethydro</code></td><td style="text-align: right"><code>Threads.nthreads()</code></td><td style="text-align: right">✓</td></tr><tr><td style="text-align: right"><code>projection</code></td><td style="text-align: right">one task per variable:</td><td style="text-align: right"><code>Threads.nthreads()</code></td><td style="text-align: right">✓</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">Nthreads &gt; Nvariables : semaphore control</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"></td><td style="text-align: right">Nthreads &lt; Nvariables: semaphore-controlled queue</td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>export_vtk</code></td><td style="text-align: right">hydro: multi-level (interpolation + mesh)</td><td style="text-align: right"><code>Threads.nthreads()</code></td><td style="text-align: right">-</td></tr><tr><td style="text-align: right"></td><td style="text-align: right">particles: each particle processed independently</td><td style="text-align: right"><code>Threads.nthreads()</code></td><td style="text-align: right">-</td></tr></table><h2 id="6-Core-Threading-Patterns"><a class="docs-heading-anchor" href="#6-Core-Threading-Patterns">6 Core Threading Patterns</a><a id="6-Core-Threading-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#6-Core-Threading-Patterns" title="Permalink"></a></h2><h3 id="6.1-Pattern-1:-Outer-Loop-Parallelism"><a class="docs-heading-anchor" href="#6.1-Pattern-1:-Outer-Loop-Parallelism">6.1 Pattern 1: Outer-Loop Parallelism</a><a id="6.1-Pattern-1:-Outer-Loop-Parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#6.1-Pattern-1:-Outer-Loop-Parallelism" title="Permalink"></a></h3><p><strong>When to use:</strong> Processing multiple independent snapshots, parameter combinations, or spatial regions.</p><p><strong>Strategy:</strong> Parallelize the outer loop, disable internal threading.</p><pre><code class="language-julia hljs">using MERA, Base.Threads

# Process multiple snapshots in parallel
snapshots = 100:25:400
results = Vector{NamedTuple}(undef, length(snapshots))

@threads for i in axes(snapshots, 1) # or use : @threads for i in 1:length(snapshots)
    snapshot = snapshots[i]
    info = getinfo(snapshot, SIMPATH)
    
    # Disable internal threading to avoid oversubscription
    gas = gethydro(info; lmax=10, max_threads=1)
    particles = getparticles(info; max_threads=1)
    
    # Perform analysis
    gas_mass = msum(gas, :Msol)
    stellar_mass = msum(particles, :Msol)
    time_myr = gettime(info, :Myr)
    
    results[i] = (
        snapshot = snapshot,
        time_myr = time_myr,
        gas_mass = gas_mass,
        stellar_mass = stellar_mass,
        total_mass = gas_mass + stellar_mass
    )
end</code></pre><h3 id="6.2-Pattern-2:-Inner-Kernel-Parallelism"><a class="docs-heading-anchor" href="#6.2-Pattern-2:-Inner-Kernel-Parallelism">6.2 Pattern 2: Inner-Kernel Parallelism</a><a id="6.2-Pattern-2:-Inner-Kernel-Parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#6.2-Pattern-2:-Inner-Kernel-Parallelism" title="Permalink"></a></h3><p><strong>When to use:</strong> Processing a single large dataset with multiple analysis types.</p><p><strong>Strategy:</strong> Let MERA&#39;s internal threading handle parallelism.</p><pre><code class="language-julia hljs">using MERA

# Load single large dataset with full parallelization
info = getinfo(400, SIMPATH)
gas = gethydro(info; lmax=12)  # Uses all available threads internally

# Create multiple projections - one thread per variable
# Each variable gets its own thread automatically
vars = [:rho, :p, :T, :vx, :vy, :vz]
p = projection(gas, vars; lmax=11) # or use: projections = projection(gas, variables; pxsize=[100., :pc]) </code></pre><h3 id="6.3-Pattern-3:-Mixed-Parallelism"><a class="docs-heading-anchor" href="#6.3-Pattern-3:-Mixed-Parallelism">6.3 Pattern 3: Mixed Parallelism</a><a id="6.3-Pattern-3:-Mixed-Parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#6.3-Pattern-3:-Mixed-Parallelism" title="Permalink"></a></h3><p><strong>When to use:</strong> Balancing multiple tasks with controlled resource allocation.</p><p><strong>Strategy:</strong> Combine outer parallelism with capped inner threading.</p><pre><code class="language-julia hljs">using MERA, Base.Threads

function analyze_simulation_comprehensive(info)
    # Allocate threads carefully across tasks
    tasks = []
    
    # Task 1: Hydro analysis (3 threads)
    push!(tasks, @spawn begin
        gas = gethydro(info; lmax=10, max_threads=3)
        density_proj = projection(gas, :rho; lmax=9, max_threads=2)
        (type=&quot;hydro&quot;, result=density_proj)
    end)
    
    # Task 2: Particle analysis (3 threads)  
    push!(tasks, @spawn begin
        particles = getparticles(info; max_threads=3)
        stellar_mass = msum(particles, :Msol)
        (type=&quot;particles&quot;, result=stellar_mass)
    end)
    
    # Task 3: Export (2 threads)
    # here: reading data again for demonstrating purposes only
    push!(tasks, @spawn begin
        gas = gethydro(info; lmax=8, max_threads=2)
        export_vtk(gas, &quot;output_$(info.output)&quot;;
                  scalars=[:rho, :p])
        (type=&quot;export&quot;, result=&quot;completed&quot;)
    end)
    
    return fetch.(tasks)  # Wait for all tasks to complete
end</code></pre><h2 id="7-Advanced-Threading-Patterns"><a class="docs-heading-anchor" href="#7-Advanced-Threading-Patterns">7 Advanced Threading Patterns</a><a id="7-Advanced-Threading-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#7-Advanced-Threading-Patterns" title="Permalink"></a></h2><h3 id="7.1-Producer-Consumer-Pipeline"><a class="docs-heading-anchor" href="#7.1-Producer-Consumer-Pipeline">7.1 Producer-Consumer Pipeline</a><a id="7.1-Producer-Consumer-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#7.1-Producer-Consumer-Pipeline" title="Permalink"></a></h3><p><strong>Use case:</strong> Streaming data processing with multiple stages.</p><pre><code class="language-julia hljs">using MERA, Base.Threads

function parallel_analysis_pipeline(snapshot_range, SIMPATH, analysis_functions)
    # Stage 1: Data loading (producer)
    data_channel = Channel{NamedTuple}(50)  # Buffered channel
    
    @spawn begin  # Producer task
        @sync for snapshot in snapshot_range
            @spawn begin
                try
                    info = getinfo(snapshot, SIMPATH)
                    gas = gethydro(info; lmax=10, max_threads=1)
                    put!(data_channel, (snapshot=snapshot, gas=gas, info=info))
                catch e
                    @warn &quot;Failed to load snapshot $snapshot: $e&quot;
                end
            end
        end
        close(data_channel)
    end
    
    # Stage 2: Analysis processing (consumers)
    results_channel = Channel{NamedTuple}(25)
    
    @spawn begin
        @sync for _ in 1:nthreads()  # Spawn consumer tasks
            @spawn begin
                for data_item in data_channel
                    try
                        # Apply all analysis functions
                        analysis_results = Dict()
                        for (func_name, func) in analysis_functions
                            analysis_results[func_name] = func(data_item.gas)
                        end
                        
                        put!(results_channel, (
                            snapshot = data_item.snapshot,
                            time_myr = gettime(data_item.info, :Myr),
                            analyses = analysis_results
                        ))
                    catch e
                        @warn &quot;Analysis failed for snapshot $(data_item.snapshot): $e&quot;
                    end
                end
            end
        end
        close(results_channel)
    end
    
    # Collect results
    return collect(results_channel)
end

# Define analysis functions
analysis_functions = [
    (:total_mass, gas -&gt; msum(gas, :Msol)),
    (:mean_density, gas -&gt; mean(getvar(gas, :rho, :nH))),
    (:mass_array, gas -&gt; getvar(gas, :mass))]</code></pre><h3 id="7.2-Adaptive-Load-Balancing"><a class="docs-heading-anchor" href="#7.2-Adaptive-Load-Balancing">7.2 Adaptive Load Balancing</a><a id="7.2-Adaptive-Load-Balancing-1"></a><a class="docs-heading-anchor-permalink" href="#7.2-Adaptive-Load-Balancing" title="Permalink"></a></h3><p><strong>Use case:</strong> Workloads with highly variable execution times (Pseudocode).</p><pre><code class="language-julia hljs">using MERA, Base.Threads

function adaptive_analysis(data_items)
    # Use @spawn for dynamic load balancing
    tasks = []
    
    for item in data_items
        task = @spawn begin
            # Execution time varies greatly by data size
            if estimate_complexity(item) &gt; COMPLEXITY_THRESHOLD
                # Use more resources for complex analysis
                complex_analysis(item; max_threads=4)
            else
                # Simple analysis needs fewer resources  
                simple_analysis(item; max_threads=1)
            end
        end
        push!(tasks, task)
    end
    
    # Fetch all results (tasks complete in variable order)
    return fetch.(tasks)
end</code></pre><p>&lt;!–### 7.3 Hierarchical Parallelism</p><p><strong>Use case:</strong> Multi-level parallel decomposition.</p><pre><code class="language-julia hljs">using MERA, Base.Threads

function hierarchical_analysis(simulation_paths)
    # Level 1: Parallel across simulations
    simulation_tasks = []
    
    for sim_path in simulation_paths
        sim_task = @spawn begin
            snapshots = find_snapshots(sim_path)
            
            # Level 2: Parallel across snapshots within simulation
            snapshot_results = Vector{Any}(undef, length(snapshots))
            @threads for (i, snap) in enuMERAte(snapshots)
                info = getinfo(snap, sim_path)
                gas = gethydro(info; lmax=9, max_threads=1)  # Serial at level 3
                
                # Level 3: Parallel across variables (controlled)
                vars = [:rho, :T, :p]
                projections = projection(gas, vars; max_threads=2)
                
                snapshot_results[i] = (snapshot=snap, projections=projections)
            end
            
            (simulation=sim_path, results=snapshot_results)
        end
        push!(simulation_tasks, sim_task)
    end
    
    return fetch.(simulation_tasks)
end</code></pre><p>–&gt;</p><h2 id="8-Thread-Safe-Programming"><a class="docs-heading-anchor" href="#8-Thread-Safe-Programming">8 Thread-Safe Programming</a><a id="8-Thread-Safe-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#8-Thread-Safe-Programming" title="Permalink"></a></h2><h3 id="8.1-Race-Conditions-and-Thread-Safety"><a class="docs-heading-anchor" href="#8.1-Race-Conditions-and-Thread-Safety">8.1 Race Conditions and Thread Safety</a><a id="8.1-Race-Conditions-and-Thread-Safety-1"></a><a class="docs-heading-anchor-permalink" href="#8.1-Race-Conditions-and-Thread-Safety" title="Permalink"></a></h3><p><strong>Race conditions</strong> occur when multiple threads access shared data simultaneously without synchronization, leading to unpredictable results:</p><pre><code class="language-julia hljs"># DANGEROUS: Race condition
total = 0.0
@threads for i in 1:1_000_000
    global total += compute_value(i)  # Multiple threads writing to same variable
end
println(total)  # Result is unpredictable!</code></pre><h3 id="8.2-Atomic-Operations"><a class="docs-heading-anchor" href="#8.2-Atomic-Operations">8.2 Atomic Operations</a><a id="8.2-Atomic-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#8.2-Atomic-Operations" title="Permalink"></a></h3><p><strong>Atomic variables</strong> provide thread-safe operations for simple data types:</p><pre><code class="language-julia hljs">using Base.Threads

# Thread-safe accumulation using atomics
total = Threads.Atomic{Float64}(0.0)
@threads for i in 1:1_000_000
    value = compute_value(i)
    atomic_add!(total, value)
end
println(&quot;Total: $(total[])&quot;)  # Reliable result</code></pre><pre><code class="language-Julia hljs"># Available atomic operations
counter = Threads.Atomic{Int}(0)
atomic_add!(counter, 5)        # Add 5
atomic_sub!(counter, 2)        # Subtract 2
old_val = atomic_xchg!(counter, 10)  # Exchange values
success = atomic_cas!(counter, 10, 20)  # Compare-and-swap

println(&quot;old_val=&quot;,old_val)
println(&quot; counter=&quot;,counter)
println(&quot; success=&quot;,success)</code></pre><h3 id="8.3-Thread-Safe-Data-Collection-Patterns"><a class="docs-heading-anchor" href="#8.3-Thread-Safe-Data-Collection-Patterns">8.3 Thread-Safe Data Collection Patterns</a><a id="8.3-Thread-Safe-Data-Collection-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#8.3-Thread-Safe-Data-Collection-Patterns" title="Permalink"></a></h3><p><strong>Pattern 1: Pre-allocated Output Arrays</strong></p><pre><code class="language-julia hljs"># Safe: Each thread writes to different indices
results = Vector{Float64}(undef, n_calculations)
@threads for i in 1:n_calculations
    results[i] = monte_carlo_step(i)  # No race condition
end</code></pre><p><strong>Pattern 2: Thread-Local Accumulators with Atomic Finalization</strong></p><pre><code class="language-julia hljs">using MERA, Base.Threads

function thread_safe_stellar_histogram(particle_data)
    ages = getvar(particle_data, :age, :Myr)
    masses = getvar(particle_data, :mass, :Msol)
    
    # Define bins and atomic counters
    age_bins = 0.0:50.0:500.0  # 0-50, 50-100, ..., 450-500 Myr
    mass_per_bin = [Atomic{Float64}(0.0) for _ in 1:(length(age_bins)-1)]
    
    # Thread-safe binning
    @threads for i in eachindex(ages)
        age = ages[i]
        mass = masses[i]
        
        # Find appropriate bin
        bin_index = searchsortedfirst(age_bins, age) - 1
        if 1 0.0, 7)) for _ in 1:nthreads()]
    
    @threads for i in eachindex(data)
        tid = threadid()
        new_sum = partial_sums[tid].value + data[i]
        partial_sums[tid] = PaddedFloat64(new_sum, partial_sums[tid].padding)
    end
    
    return sum(ps.value for ps in partial_sums)
end</code></pre><h3 id="8.4-Locks-for-Complex-Data-Structures"><a class="docs-heading-anchor" href="#8.4-Locks-for-Complex-Data-Structures">8.4 Locks for Complex Data Structures</a><a id="8.4-Locks-for-Complex-Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#8.4-Locks-for-Complex-Data-Structures" title="Permalink"></a></h3><p>For complex shared data structures that can&#39;t use atomics:</p><pre><code class="language-julia hljs">using Base.Threads: ReentrantLock

# Thread-safe access to complex data structures
lock = ReentrantLock()
shared_results = Dict{String, Vector{Float64}}()

@threads for analysis_id in analysis_ids
    result_vector = perform_complex_analysis(analysis_id)
    
    # Thread-safe dictionary update
    lock(lock) do
        shared_results[analysis_id] = result_vector
    end
end</code></pre><h2 id="9-Transforming-Single-Threaded-Tutorials"><a class="docs-heading-anchor" href="#9-Transforming-Single-Threaded-Tutorials">9 Transforming Single-Threaded Tutorials</a><a id="9-Transforming-Single-Threaded-Tutorials-1"></a><a class="docs-heading-anchor-permalink" href="#9-Transforming-Single-Threaded-Tutorials" title="Permalink"></a></h2><h3 id="9.1-Tutorial-Transformation-Overview"><a class="docs-heading-anchor" href="#9.1-Tutorial-Transformation-Overview">9.1 Tutorial Transformation Overview</a><a id="9.1-Tutorial-Transformation-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#9.1-Tutorial-Transformation-Overview" title="Permalink"></a></h3><table><tr><th style="text-align: right">Original Tutorial</th><th style="text-align: right">Multi-Threading Opportunity</th><th style="text-align: right">Pattern Type</th></tr><tr><td style="text-align: right">01<em>hydro</em>First_Inspection.ipynb</td><td style="text-align: right">Load multiple snapshots in parallel</td><td style="text-align: right">Outer-loop</td></tr><tr><td style="text-align: right">02<em>hydro</em>Load_Selections.ipynb</td><td style="text-align: right">Filter multiple regions simultaneously</td><td style="text-align: right">Outer-loop</td></tr><tr><td style="text-align: right">03<em>hydro</em>Get_Subregions.ipynb</td><td style="text-align: right">Extract subregions in parallel</td><td style="text-align: right">Outer-loop</td></tr><tr><td style="text-align: right">06<em>hydro</em>Projection.ipynb</td><td style="text-align: right">Project multiple variables at once</td><td style="text-align: right">Inner-kernel</td></tr><tr><td style="text-align: right">06<em>particles</em>Projection.ipynb</td><td style="text-align: right">Parallel particle projections</td><td style="text-align: right">Mixed</td></tr><tr><td style="text-align: right">08<em>hydro</em>VTK_export.ipynb</td><td style="text-align: right">Export multiple outputs simultaneously</td><td style="text-align: right">Outer-loop</td></tr><tr><td style="text-align: right">08<em>particles</em>VTK_export.ipynb</td><td style="text-align: right">Parallel particle exports</td><td style="text-align: right">Mixed</td></tr></table><h3 id="9.2-Example-1:-Parallel-First-Inspection"><a class="docs-heading-anchor" href="#9.2-Example-1:-Parallel-First-Inspection">9.2 Example 1: Parallel First Inspection</a><a id="9.2-Example-1:-Parallel-First-Inspection-1"></a><a class="docs-heading-anchor-permalink" href="#9.2-Example-1:-Parallel-First-Inspection" title="Permalink"></a></h3><p><em>Transforming 01<em>hydro</em>First_Inspection.ipynb</em></p><p><strong>Original (single-threaded):</strong></p><pre><code class="language-julia hljs">using MERA

# Load and inspect one snapshot
info = getinfo(100, SIMPATH)
gas = gethydro(info; lmax=10)

println(&quot;Time: &quot;, gettime(info, :Myr), &quot; Myr&quot;)
println(&quot;Total mass: &quot;, msum(gas, :Msol), &quot; Msol&quot;)
println(&quot;Number of cells: &quot;, length(gas.data))</code></pre><p><strong>Multi-threaded version:</strong></p><pre><code class="language-julia hljs">using MERA, Base.Threads

# Inspect multiple snapshots in parallel
snapshots = 100:25:400
results = Vector{NamedTuple}(undef, length(snapshots))

@threads for (i, snapshot) in enuMERAte(snapshots)
    info = getinfo(snapshot, SIMPATH)
    # Use max_threads=1 to avoid oversubscription in outer loop
    gas = gethydro(info; lmax=10, max_threads=1)
    
    results[i] = (
        snapshot = snapshot,
        time_myr = gettime(info, :Myr),
        total_mass = msum(gas, :Msol),
        n_cells = length(gas.data),
        mean_density = mean(getvar(gas, :rho, :nH))
    )
end

# Display results
for r in results
    println(&quot;Snapshot $(r.snapshot): $(r.time_myr) Myr, $(r.total_mass) Msol&quot;)
end</code></pre><h3 id="9.3-Example-2:-Parallel-Selections"><a class="docs-heading-anchor" href="#9.3-Example-2:-Parallel-Selections">9.3 Example 2: Parallel Selections</a><a id="9.3-Example-2:-Parallel-Selections-1"></a><a class="docs-heading-anchor-permalink" href="#9.3-Example-2:-Parallel-Selections" title="Permalink"></a></h3><p><em>Transforming 02<em>hydro</em>Load_Selections.ipynb</em></p><p><strong>Original (single-threaded):</strong></p><pre><code class="language-julia hljs"># Load different spatial selections sequentially
info = getinfo(200, SIMPATH)

# Central region
gas_center = gethydro(info; xrange=[-5,5], yrange=[-5,5], zrange=[-2,2])
mass_center = msum(gas_center, :Msol)

# Disk region  
gas_disk = gethydro(info; xrange=[-10,10], yrange=[-10,10], zrange=[-1,1])
mass_disk = msum(gas_disk, :Msol)</code></pre><p><strong>Multi-threaded version:</strong></p><pre><code class="language-julia hljs">using MERA, Base.Threads

# Define multiple spatial selections
selections = [
    (name=&quot;center&quot;, xrange=[-5,5], yrange=[-5,5], zrange=[-2,2]),
    (name=&quot;disk&quot;, xrange=[-10,10], yrange=[-10,10], zrange=[-1,1]),
    (name=&quot;halo&quot;, xrange=[-25,25], yrange=[-25,25], zrange=[-10,10]),
    (name=&quot;north&quot;, xrange=[-15,15], yrange=[-15,15], zrange=[2,8])
]

results = Vector{NamedTuple}(undef, length(selections))

@threads for (i, sel) in enuMERAte(selections)
    info = getinfo(200, SIMPATH)
    # Extract selection parameters (excluding name)
    selection_kwargs = [(k,v) for (k,v) in pairs(sel) if k != :name]
    
    gas = gethydro(info; lmax=10, max_threads=1, selection_kwargs...)
    
    results[i] = (
        region = sel.name,
        mass = msum(gas, :Msol),
        volume = (sel.xrange[2]-sel.xrange[1]) * 
                (sel.yrange[2]-sel.yrange[1]) * 
                (sel.zrange[2]-sel.zrange[1]),
        mean_density = mean(getvar(gas, :rho, :nH))
    )
end

# Compare regions
for r in results
    density_msol_pc3 = r.mass / r.volume * (1000/3.086e18)^3
    println(&quot;$(r.region): $(r.mass) Msol, density $(density_msol_pc3) Msol/pc³&quot;)
end</code></pre><h3 id="9.4-Example-3:-Parallel-Projections"><a class="docs-heading-anchor" href="#9.4-Example-3:-Parallel-Projections">9.4 Example 3: Parallel Projections</a><a id="9.4-Example-3:-Parallel-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#9.4-Example-3:-Parallel-Projections" title="Permalink"></a></h3><p><em>Transforming 06<em>hydro</em>Projection.ipynb</em></p><p><strong>Original (single-threaded):</strong></p><pre><code class="language-julia hljs"># Create projections one by one
info = getinfo(300, SIMPATH)
gas = gethydro(info; lmax=11)

# Sequential projections
rho_map = projection(gas, :rho; direction=:z, lmax=9)  
temp_map = projection(gas, :T; direction=:z, lmax=9)
vel_map = projection(gas, :vz; direction=:z, lmax=9)</code></pre><p><strong>Multi-threaded version:</strong></p><pre><code class="language-julia hljs">using MERA

info = getinfo(300, SIMPATH)
gas = gethydro(info; lmax=11)  # Full parallelization for loading

# Create all projections at once - one thread per variable
variables = [:rho, :T, :vz, :p]
projections = projection(gas, variables; direction=:z, lmax=9)

# Access individual projections
rho_map = projections  # If single variable, returns the map directly
# For multiple variables, projections contains all maps

# Alternative: Use @spawn for more control
tasks = [Threads.@spawn projection(gas, var; direction=:z, lmax=9, max_threads=2) 
         for var in variables]
projection_results = fetch.(tasks)</code></pre><h3 id="9.5-Example-4:-Parallel-VTK-Export"><a class="docs-heading-anchor" href="#9.5-Example-4:-Parallel-VTK-Export">9.5 Example 4: Parallel VTK Export</a><a id="9.5-Example-4:-Parallel-VTK-Export-1"></a><a class="docs-heading-anchor-permalink" href="#9.5-Example-4:-Parallel-VTK-Export" title="Permalink"></a></h3><p><em>Transforming 08<em>hydro</em>VTK_export.ipynb</em></p><p><strong>Original (single-threaded):</strong></p><pre><code class="language-julia hljs"># Export one snapshot to VTK
info = getinfo(250, SIMPATH)
gas = gethydro(info; lmax=10)

export_vtk(gas, &quot;hydro_snapshot_250&quot;;
          scalars=[:rho, :p, :T],
          scalars_unit=[:nH, :K, :K])</code></pre><p><strong>Multi-threaded version:</strong></p><pre><code class="language-julia hljs">using MERA, Base.Threads

# Export multiple snapshots in parallel
snapshots = 200:50:400
export_dir = &quot;./vtk_exports&quot;
mkpath(export_dir)  # Create directory

@threads for snapshot in snapshots
    try
        info = getinfo(snapshot, SIMPATH)
        # Load with reduced internal threading
        gas = gethydro(info; lmax=10, max_threads=2)
        
        # Create timestamped filename
        time_myr = gettime(info, :Myr)
        filename = joinpath(export_dir, &quot;hydro_$(snapshot)_t$(time_myr)Myr&quot;)
        
        # VTK export can use more threads for I/O
        export_vtk(gas, filename;
                  scalars=[:rho, :p, :T],
                  scalars_unit=[:nH, :K, :K],
                  vector=[:vx, :vy, :vz],
                  vector_unit=:km_s,
                  max_threads=4)  # I/O benefits from more threads
        
        println(&quot;Exported snapshot $snapshot&quot;)
        
    catch e
        @error &quot;Failed to export snapshot $snapshot: $e&quot;
    end
end

println(&quot;VTK export completed for $(length(snapshots)) snapshots&quot;)</code></pre><h2 id="10-Benchmarking-and-Performance-Tuning"><a class="docs-heading-anchor" href="#10-Benchmarking-and-Performance-Tuning">10 Benchmarking &amp; Performance Tuning</a><a id="10-Benchmarking-and-Performance-Tuning-1"></a><a class="docs-heading-anchor-permalink" href="#10-Benchmarking-and-Performance-Tuning" title="Permalink"></a></h2><h3 id="10.1-Finding-Optimal-max_threads-Values"><a class="docs-heading-anchor" href="#10.1-Finding-Optimal-max_threads-Values">10.1 Finding Optimal <code>max_threads</code> Values</a><a id="10.1-Finding-Optimal-max_threads-Values-1"></a><a class="docs-heading-anchor-permalink" href="#10.1-Finding-Optimal-max_threads-Values" title="Permalink"></a></h3><p>Different functions have different optimal thread counts. Benchmark systematically:</p><pre><code class="language-julia hljs">using MERA, BenchmarkTools

function benchmark_gethydro(info)
    println(&quot;Benchmarking gethydro with different max_threads:&quot;)
    for t in (1, 2, 4, 8, Threads.nthreads())
        # Use @belapsed for single measurement (more reliable than @btime here)
        time = @belapsed gethydro($info; lmax=12, max_threads=$t)
        println(&quot;  max_threads=$t → $(round(time, digits=3)) seconds&quot;)
    end
end

function benchmark_projection(gas)
    println(&quot;Benchmarking projection with different max_threads:&quot;)
    vars = [:rho, :T, :vx, :vy]  # 4 variables
    
    for t in (1, 2, 4, 8, min(8, Threads.nthreads()))
        time = @belapsed projection($gas, $vars; lmax=10, max_threads=$t)
        println(&quot;  max_threads=$t → $(round(time, digits=3)) seconds&quot;)
    end
end

function benchmark_export_vtk(gas, temp_prefix)
    println(&quot;Benchmarking export_vtk with different max_threads:&quot;)
    
    for t in (1, 2, 4, 8, min(8, Threads.nthreads()))
        filename = &quot;$(temp_prefix)_$(t)threads&quot;
        time = @belapsed begin
            export_vtk($gas, $filename; scalars=[:rho], max_threads=$t)
            # Clean up
            rm(&quot;$(filename).vti&quot;, force=true)
        end
        println(&quot;  max_threads=$t → $(round(time, digits=3)) seconds&quot;)
    end
end

# Run benchmarks
info = getinfo(300, SIMPATH)
gas = gethydro(info; lmax=10, max_threads=1)  # Load once for projection tests

benchmark_gethydro(info)
benchmark_projection(gas)
benchmark_export_vtk(gas, &quot;./benchmark_temp&quot;)</code></pre><p><strong>Example Output:</strong></p><pre><code class="nohighlight hljs">Benchmarking gethydro with different max_threads:
  max_threads=1 → 3.245 seconds
  max_threads=2 → 1.823 seconds
  max_threads=4 → 1.156 seconds
  max_threads=8 → 1.089 seconds
  max_threads=16 → 1.092 seconds

Benchmarking projection with different max_threads:
  max_threads=1 → 2.134 seconds
  max_threads=2 → 1.087 seconds
  max_threads=4 → 0.589 seconds  ← Sweet spot
  max_threads=8 → 0.591 seconds</code></pre><h3 id="10.2-Memory-Usage-Monitoring"><a class="docs-heading-anchor" href="#10.2-Memory-Usage-Monitoring">10.2 Memory Usage Monitoring</a><a id="10.2-Memory-Usage-Monitoring-1"></a><a class="docs-heading-anchor-permalink" href="#10.2-Memory-Usage-Monitoring" title="Permalink"></a></h3><p>Monitor memory allocation and GC performance:</p><pre><code class="language-julia hljs">function monitor_memory_usage(analysis_function, data)
    println(&quot;Memory usage analysis:&quot;)
    
    # Clear previous allocations
    GC.gc()
    initial_gc = GC.gc_num()
    
    # Run analysis with detailed timing
    result = @time analysis_function(data)
    
    # Calculate memory statistics
    final_gc = GC.gc_num()
    
    allocated_mb = (final_gc.allocd - initial_gc.allocd) / 1024^2
    gc_time_ms = (final_gc.total_time - initial_gc.total_time) / 1e6
    
    println(&quot;  Total allocated: $(round(allocated_mb, digits=1)) MB&quot;)
    println(&quot;  GC time: $(round(gc_time_ms, digits=1)) ms&quot;)
    
    if gc_time_ms &gt; 500  # More than 0.5s in GC
        println(&quot;  ⚠️  High GC time detected. Consider:&quot;)
        println(&quot;     - Increasing --gcthreads&quot;)
        println(&quot;     - Pre-allocating arrays&quot;)  
        println(&quot;     - Using in-place operations&quot;)
        println(&quot;     - Processing data in smaller chunks&quot;)
    end
    
    return result
end

# Example usage
function test_analysis(snapshots)
    @threads for s in snapshots
        info = getinfo(s, SIMPATH)
        gas = gethydro(info; lmax=10, max_threads=1)
        msum(gas, :Msol)
    end
end

result = monitor_memory_usage(test_analysis, 100:10:150)</code></pre><h3 id="10.3-Thread-Utilization-Analysis"><a class="docs-heading-anchor" href="#10.3-Thread-Utilization-Analysis">10.3 Thread Utilization Analysis</a><a id="10.3-Thread-Utilization-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#10.3-Thread-Utilization-Analysis" title="Permalink"></a></h3><p>Check if threads are being used efficiently:</p><pre><code class="language-julia hljs">function analyze_thread_utilization(workload_function)
    # Track work distribution across threads
    work_counters = [Threads.Atomic{Int}(0) for _ in 1:Threads.nthreads()]
    
    # Modified workload that tracks thread usage
    function tracked_workload(args...)
        tid = Threads.threadid()
        Threads.atomic_add!(work_counters[tid], 1)
        return workload_function(args...)
    end
    
    # Run the workload
    start_time = time()
    result = tracked_workload()
    end_time = time()
    
    # Analyze utilization
    work_counts = [counter[] for counter in work_counters]
    total_work = sum(work_counts)
    
    println(&quot;Thread utilization analysis:&quot;)
    println(&quot;  Total execution time: $(round(end_time - start_time, digits=2))s&quot;)
    println(&quot;  Total work units: $total_work&quot;)
    
    for (i, count) in enuMERAte(work_counts)
        if count &gt; 0
            percentage = round(count / total_work * 100, digits=1)
            println(&quot;  Thread $i: $count tasks ($(percentage)%)&quot;)
        end
    end
    
    # Load balance coefficient of variation (lower is better)
    active_threads = sum(work_counts .&gt; 0)
    if active_threads &gt; 1
        cv = std(work_counts) / mean(work_counts)
        println(&quot;  Load balance CV: $(round(cv, digits=3)) (lower is better)&quot;)
        
        if cv &gt; 0.5
            println(&quot;  ⚠️  Poor load balance detected. Consider:&quot;)
            println(&quot;     - Using @spawn instead of @threads for variable workloads&quot;)
            println(&quot;     - Reducing task granularity&quot;)
        end
    end
    
    return result
end</code></pre><h2 id="11-Best-Practices-and-Troubleshooting"><a class="docs-heading-anchor" href="#11-Best-Practices-and-Troubleshooting">11 Best Practices &amp; Troubleshooting</a><a id="11-Best-Practices-and-Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#11-Best-Practices-and-Troubleshooting" title="Permalink"></a></h2><h3 id="11.1-Threading-Best-Practices"><a class="docs-heading-anchor" href="#11.1-Threading-Best-Practices">11.1 Threading Best Practices</a><a id="11.1-Threading-Best-Practices-1"></a><a class="docs-heading-anchor-permalink" href="#11.1-Threading-Best-Practices" title="Permalink"></a></h3><p><strong>1. Choose One Level of Parallelism</strong></p><pre><code class="language-julia hljs"># GOOD: Outer loop parallelism
@threads for snapshot in snapshots
    gas = gethydro(info; max_threads=1)  # Inner serial
end

# GOOD: Inner parallelism  
gas = gethydro(info)  # Full threads
projections = projection(gas, variables)  # One thread per variable

# AVOID: Uncontrolled nesting
@threads for snapshot in snapshots
    gas = gethydro(info)  # Full threads
    projection(gas, variables)  # More full threads = oversubscription
end</code></pre><p><strong>2. Cap Threads Appropriately</strong></p><pre><code class="language-julia hljs"># Rule of thumb for max_threads:
# - I/O bound: Higher thread counts (4-8)
# - CPU bound: Match physical cores  
# - Memory bound: Lower thread counts (2-4)

export_vtk(gas, filename; max_threads=8)        # I/O benefits from more threads
projection(gas, vars; max_threads=4)            # CPU bound, moderate threads
gethydro(info; max_threads=2)                   # Memory bound, fewer threads</code></pre><p><strong>3. Monitor and Profile</strong></p><pre><code class="language-julia hljs"># Always check GC overhead
@time result = your_analysis_function()
# Look for &quot;% gc time&quot; - keep it under 15%

# Use BenchmarkTools for reliable measurements
@benchmark your_function($args)

# Profile allocation hotspots
using Profile
@profile your_function(args)
Profile.print()</code></pre><p><strong>4. Handle Errors Gracefully</strong></p><pre><code class="language-julia hljs">@threads for item in workload
    try
        process_item(item)
    catch e
        @error &quot;Failed to process $item: $e&quot;
    end
end</code></pre><h3 id="11.2-Common-Issues-and-Solutions"><a class="docs-heading-anchor" href="#11.2-Common-Issues-and-Solutions">11.2 Common Issues and Solutions</a><a id="11.2-Common-Issues-and-Solutions-1"></a><a class="docs-heading-anchor-permalink" href="#11.2-Common-Issues-and-Solutions" title="Permalink"></a></h3><p><strong>Issue 1: Poor Scaling Performance</strong></p><pre><code class="nohighlight hljs">Symptom: Adding more threads doesn&#39;t improve (or worsens) performance</code></pre><p><strong>Causes and Solutions:</strong></p><ul><li><strong>Memory bandwidth bottleneck</strong>: Reduce threads to match memory channels (typically 4-8)</li><li><strong>False sharing</strong>: Use padding or redesign data structures  </li><li><strong>Over-synchronization</strong>: Minimize shared state, use thread-local storage</li><li><strong>I/O contention</strong>: For network storage, fewer threads may be better</li></ul><p><strong>Issue 2: High GC Time</strong></p><pre><code class="nohighlight hljs">Symptom: @time shows &gt;20% gc time</code></pre><p><strong>Solutions:</strong></p><pre><code class="language-julia hljs"># Increase GC threads
# julia --gcthreads=8

# Pre-allocate arrays
results = Vector{Float64}(undef, n)  # Instead of growing with push!

# Use in-place operations  
@. array1 += array2  # Instead of array1 = array1 + array2

# Process in chunks
for chunk in data_chunks
    process(chunk)
    GC.gc()  # Force cleanup between chunks
end</code></pre><p><strong>Issue 3: Crashes or Incorrect Results</strong></p><pre><code class="nohighlight hljs">Symptom: Program crashes, hangs, or produces wrong answers</code></pre><p><strong>Causes and Solutions:</strong></p><ul><li><strong>Race conditions</strong>: Use atomics or locks for shared data</li><li><strong>Unsafe library usage</strong>: Many C libraries aren&#39;t thread-safe  </li><li><strong>Stack overflow</strong>: Large recursion depths on multiple threads</li></ul><h3 id="11.3-Debugging-Multi-Threaded-Code"><a class="docs-heading-anchor" href="#11.3-Debugging-Multi-Threaded-Code">11.3 Debugging Multi-Threaded Code</a><a id="11.3-Debugging-Multi-Threaded-Code-1"></a><a class="docs-heading-anchor-permalink" href="#11.3-Debugging-Multi-Threaded-Code" title="Permalink"></a></h3><p><strong>Use Thread-Safe Debugging</strong></p><pre><code class="language-julia hljs">using Base.Threads: SpinLock

debug_lock = SpinLock()
function thread_safe_debug(msg)
    lock(debug_lock) do
        println(&quot;Thread $(threadid()): $msg&quot;)
    end
end

@threads for i in 1:10
    thread_safe_debug(&quot;Processing item $i&quot;)
    # ... work ...
    thread_safe_debug(&quot;Completed item $i&quot;)
end</code></pre><p><strong>Detect Race Conditions</strong></p><pre><code class="language-julia hljs">function test_for_race_conditions(test_function, n_trials=100)
    reference_result = test_function()  # Serial reference
    
    for trial in 1:n_trials
        result = test_function()
        if result != reference_result
            error(&quot;Race condition detected in trial $trial!&quot;)
        end
    end
    
    println(&quot;No race conditions detected over $n_trials trials&quot;)
end</code></pre><h2 id="12-Complete-Working-Examples"><a class="docs-heading-anchor" href="#12-Complete-Working-Examples">12 Complete Working Examples</a><a id="12-Complete-Working-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#12-Complete-Working-Examples" title="Permalink"></a></h2><h3 id="12.1-Multi-Simulation-Analysis-Pipeline"><a class="docs-heading-anchor" href="#12.1-Multi-Simulation-Analysis-Pipeline">12.1 Multi-Simulation Analysis Pipeline</a><a id="12.1-Multi-Simulation-Analysis-Pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#12.1-Multi-Simulation-Analysis-Pipeline" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MERA, Base.Threads
using Statistics, Printf

function comprehensive_analysis_pipeline(simulation_paths)
    &quot;&quot;&quot;
    Complete pipeline: load simulations, analyze multiple snapshots,
    create projections, and export results with full threading control.
    &quot;&quot;&quot;
    
    all_results = []
    
    # Outer level: Parallel across simulations
    @threads for sim_path in simulation_paths
        println(&quot;Analyzing simulation: $sim_path&quot;)
        
        try
            # Find available snapshots
            snapshots = find_snapshots_in_path(sim_path)  # Custom function
            sim_results = []
            
            # Process snapshots in this simulation
            for snapshot in snapshots
                info = getinfo(snapshot, sim_path)
                time_myr = gettime(info, :Myr)
                
                # Load data with controlled threading
                gas = gethydro(info; lmax=10, max_threads=2)
                particles = getparticles(info; max_threads=2)
                
                # Parallel projections - one thread per variable
                gas_variables = [:rho, :T, :p]
                gas_projections = projection(gas, gas_variables; 
                                           direction=:z, lmax=9, max_threads=3)
                
                # Particle projection
                particle_proj = projection(particles, :mass; 
                                         direction=:z, max_threads=1)
                
                # Analysis calculations
                gas_mass = msum(gas, :Msol)
                stellar_mass = msum(particles, :Msol)
                mean_density = mean(getvar(gas, :rho, :nH))
                mean_temp = mean(getvar(gas, :T, :K))
                
                # Store results
                push!(sim_results, (
                    snapshot = snapshot,
                    time_myr = time_myr,
                    gas_mass = gas_mass,
                    stellar_mass = stellar_mass,
                    mean_density = mean_density,
                    mean_temperature = mean_temp,
                    gas_projections = gas_projections,
                    particle_projection = particle_proj
                ))
            end
            
            # Thread-safe addition to global results
            push!(all_results, (simulation=sim_path, snapshots=sim_results))
            
        catch e
            @error &quot;Failed to analyze simulation $sim_path: $e&quot;
        end
    end
    
    return all_results
end

function find_snapshots_in_path(path)
    # Placeholder - implement based on your file structure
    return 100:50:500
end

# Usage
simulation_paths = [&quot;/data/sim_001&quot;, &quot;/data/sim_002&quot;, &quot;/data/sim_003&quot;]
results = comprehensive_analysis_pipeline(simulation_paths)

# Process results
for sim_result in results
    println(&quot;Simulation: $(sim_result.simulation)&quot;)
    for snap_result in sim_result.snapshots
        @printf(&quot;  t=%.1f Myr: Gas=%.2e Msol, Stars=%.2e Msol, T̄=%.1f K\n&quot;,
                snap_result.time_myr, snap_result.gas_mass, 
                snap_result.stellar_mass, snap_result.mean_temperature)
    end
end</code></pre><h3 id="12.2-Parameter-Study-with-Threading"><a class="docs-heading-anchor" href="#12.2-Parameter-Study-with-Threading">12.2 Parameter Study with Threading</a><a id="12.2-Parameter-Study-with-Threading-1"></a><a class="docs-heading-anchor-permalink" href="#12.2-Parameter-Study-with-Threading" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MERA, Base.Threads

function parallel_parameter_study()
    &quot;&quot;&quot;
    Run analysis across multiple parameter combinations in parallel
    &quot;&quot;&quot;
    
    # Define parameter grid
    lmax_values = [8, 9, 10, 11]
    center_positions = [[24, 24, 24], [25, 25, 25], [23, 23, 23]]
    box_sizes = [5, 10, 15]  # kpc
    
    # Create all parameter combinations
    param_combinations = [(lmax=l, center=c, size=s) 
                         for l in lmax_values 
                         for c in center_positions 
                         for s in box_sizes]
    
    results = Vector{NamedTuple}(undef, length(param_combinations))
    
    # Process parameter combinations in parallel
    @threads for (i, params) in enuMERAte(param_combinations)
        try
            info = getinfo(300, SIMPATH)
            
            # Load data with parameter-specific settings
            gas = gethydro(info; 
                          lmax = params.lmax,
                          center = params.center,
                          xrange = [-params.size, params.size],
                          yrange = [-params.size, params.size],
                          zrange = [-params.size, params.size],
                          range_unit = :kpc,
                          max_threads = 1)  # Serial inside threaded loop
            
            # Perform analysis
            total_mass = msum(gas, :Msol)
            mean_density = mean(getvar(gas, :rho, :nH))
            n_cells = length(gas.data)
            
            # Create projection
            density_proj = projection(gas, :rho; direction=:z, 
                                    lmax=params.lmax-1, max_threads=2)
            
            # Store results
            results[i] = (
                parameters = params,
                total_mass = total_mass,
                mean_density = mean_density,
                n_cells = n_cells,
                projection = density_proj,
                success = true
            )
            
        catch e
            @error &quot;Parameter combination $params failed: $e&quot;
            results[i] = (parameters=params, success=false, error=e)
        end
    end
    
    # Filter successful results and analyze
    successful_results = filter(r -&gt; r.success, results)
    
    println(&quot;Parameter study completed:&quot;)
    println(&quot;  Total combinations: $(length(param_combinations))&quot;)
    println(&quot;  Successful: $(length(successful_results))&quot;)
    
    # Find optimal parameters (example: maximize resolved cells)
    best_result = findmax(r -&gt; r.n_cells, successful_results)[2]
    
    println(&quot;Best parameters (most cells resolved):&quot;)
    println(&quot;  lmax: $(successful_results[best_result].parameters.lmax)&quot;)
    println(&quot;  center: $(successful_results[best_result].parameters.center)&quot;)  
    println(&quot;  size: $(successful_results[best_result].parameters.size) kpc&quot;)
    println(&quot;  cells: $(successful_results[best_result].n_cells)&quot;)
    
    return successful_results
end

# Run parameter study
study_results = parallel_parameter_study()</code></pre><h3 id="12.3-Time-Series-Analysis-with-Memory-Management"><a class="docs-heading-anchor" href="#12.3-Time-Series-Analysis-with-Memory-Management">12.3 Time Series Analysis with Memory Management</a><a id="12.3-Time-Series-Analysis-with-Memory-Management-1"></a><a class="docs-heading-anchor-permalink" href="#12.3-Time-Series-Analysis-with-Memory-Management" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MERA, Base.Threads
using Statistics

function memory_efficient_time_series(snapshot_range, chunk_size=5)
    &quot;&quot;&quot;
    Process time series in chunks to manage memory usage
    &quot;&quot;&quot;
    
    # Pre-allocate result arrays  
    n_snapshots = length(snapshot_range)
    times = Vector{Float64}(undef, n_snapshots)
    gas_masses = Vector{Float64}(undef, n_snapshots)
    stellar_masses = Vector{Float64}(undef, n_snapshots)
    mean_densities = Vector{Float64}(undef, n_snapshots)
    mean_temperatures = Vector{Float64}(undef, n_snapshots)
    
    # Process in chunks to manage memory
    for chunk_start in 1:chunk_size:n_snapshots
        chunk_end = min(chunk_start + chunk_size - 1, n_snapshots)
        chunk_indices = chunk_start:chunk_end
        
        println(&quot;Processing chunk $(chunk_start):$(chunk_end)&quot;)
        
        # Process chunk in parallel
        @threads for i in chunk_indices
            snapshot = snapshot_range[i]
            
            try
                info = getinfo(snapshot, SIMPATH)
                
                # Load data with memory-conscious settings
                gas = gethydro(info; lmax=10, max_threads=1)
                particles = getparticles(info; max_threads=1)
                
                # Extract variables efficiently
                gas_rho = getvar(gas, :rho, :nH)
                gas_temp = getvar(gas, :T, :K)
                gas_mass_vals = getvar(gas, :mass, :Msol)
                particle_masses = getvar(particles, :mass, :Msol)
                
                # Compute and store results
                times[i] = gettime(info, :Myr)
                gas_masses[i] = sum(gas_mass_vals)
                stellar_masses[i] = sum(particle_masses)
                mean_densities[i] = mean(gas_rho)
                mean_temperatures[i] = mean(gas_temp)
                
            catch e
                @error &quot;Failed to process snapshot $snapshot: $e&quot;
                # Fill with NaN for failed snapshots
                times[i] = NaN
                gas_masses[i] = NaN  
                stellar_masses[i] = NaN
                mean_densities[i] = NaN
                mean_temperatures[i] = NaN
            end
        end
        
        # Force garbage collection between chunks
        GC.gc()
        println(&quot;Chunk completed, memory freed&quot;)
    end
    
    # Filter out failed snapshots
    valid_indices = .!isnan.(times)
    
    return (
        times = times[valid_indices],
        gas_masses = gas_masses[valid_indices],
        stellar_masses = stellar_masses[valid_indices],
        mean_densities = mean_densities[valid_indices],
        mean_temperatures = mean_temperatures[valid_indices],
        n_successful = sum(valid_indices),
        n_failed = sum(.!valid_indices)
    )
end

# Run time series analysis
results = memory_efficient_time_series(100:10:500, 10)  # Process 10 snapshots at a time

println(&quot;Time series analysis completed:&quot;)
println(&quot;  Successful snapshots: $(results.n_successful)&quot;)
println(&quot;  Failed snapshots: $(results.n_failed)&quot;)
println(&quot;  Time range: $(minimum(results.times)) - $(maximum(results.times)) Myr&quot;)
println(&quot;  Gas mass range: $(minimum(results.gas_masses)) - $(maximum(results.gas_masses)) Msol&quot;)</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This comprehensive guide provides everything needed to harness Julia&#39;s multi-threading capabilities with MERA:</p><p><strong>Key Takeaways:</strong></p><ol><li><strong>Understand oversubscription</strong> and use <code>max_threads</code> to prevent it</li><li><strong>Choose your parallelization level</strong> - outer loops or inner kernels, not both uncontrolled</li><li><strong>Benchmark systematically</strong> to find optimal thread counts for your hardware  </li><li><strong>Monitor GC performance</strong> and tune for large dataset processing</li><li><strong>Transform existing tutorials</strong> with minimal code changes for immediate benefits</li></ol><p><strong>Threading Patterns:</strong></p><ul><li><strong>Outer-loop</strong>: Multiple snapshots/parameters → <code>@threads</code> + <code>max_threads=1</code> inner</li><li><strong>Inner-kernel</strong>: Single large dataset → full internal threading in MERA calls</li><li><strong>Mixed</strong>: Controlled combination with explicit thread budgets</li></ul><p><strong>Best Practices:</strong></p><ul><li>Start Julia with balanced thread pools: <code>julia --threads=auto --gcthreads=auto</code></li><li>Use atomic operations for thread-safe data collection</li><li>Avoid false sharing with proper data structure design</li><li>Profile and benchmark before optimizing</li></ul><p>By following these patterns, you can transform single-threaded analysis scripts into high-throughput, scalable workflows that fully utilize modern multi-core processors—all within pure Julia code, no external dependencies required.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/">« 10 Examples</a><a class="docs-footer-nextpage" href="../../benchmarks/IO/IOperformance/">Server IO »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 28 July 2025 17:59">Monday 28 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
